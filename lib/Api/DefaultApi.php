<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  WooCommerce\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * wc/v3
 *
 * OpenAPI documented, based on generated OpenAPI document of the namespace wc/v3 with some manual fixes.
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.41
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace WooCommerce\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WooCommerce\Client\ApiException;
use WooCommerce\Client\Configuration;
use WooCommerce\Client\HeaderSelector;
use WooCommerce\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  WooCommerce\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation couponsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $code Limit result set to resources with a specific code. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopCoupon[]
     */
    public function couponsGet($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $code = null)
    {
        list($response) = $this->couponsGetWithHttpInfo($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $code);
        return $response;
    }

    /**
     * Operation couponsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $code Limit result set to resources with a specific code. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopCoupon[], HTTP status code, HTTP response headers (array of strings)
     */
    public function couponsGetWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $code = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon[]';
        $request = $this->couponsGetRequest($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopCoupon[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation couponsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $code Limit result set to resources with a specific code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsGetAsync($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $code = null)
    {
        return $this->couponsGetAsyncWithHttpInfo($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation couponsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $code Limit result set to resources with a specific code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $code = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon[]';
        $request = $this->couponsGetRequest($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'couponsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $code Limit result set to resources with a specific code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function couponsGetRequest($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $code = null)
    {

        $resourcePath = '/coupons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if ($after !== null) {
            $queryParams['after'] = ObjectSerializer::toQueryValue($after, 'string');
        }
        // query params
        if ($before !== null) {
            $queryParams['before'] = ObjectSerializer::toQueryValue($before, 'string');
        }
        // query params
        if ($modified_after !== null) {
            $queryParams['modified_after'] = ObjectSerializer::toQueryValue($modified_after, 'string');
        }
        // query params
        if ($modified_before !== null) {
            $queryParams['modified_before'] = ObjectSerializer::toQueryValue($modified_before, 'string');
        }
        // query params
        if ($dates_are_gmt !== null) {
            $queryParams['dates_are_gmt'] = ObjectSerializer::toQueryValue($dates_are_gmt, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation couponsIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopCoupon
     */
    public function couponsIdDelete($id, $force = null)
    {
        list($response) = $this->couponsIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation couponsIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopCoupon, HTTP status code, HTTP response headers (array of strings)
     */
    public function couponsIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopCoupon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation couponsIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdDeleteAsync($id, $force = null)
    {
        return $this->couponsIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation couponsIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'couponsIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function couponsIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling couponsIdDelete'
            );
        }

        $resourcePath = '/coupons/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation couponsIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopCoupon
     */
    public function couponsIdGet($id, $context = null)
    {
        list($response) = $this->couponsIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation couponsIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopCoupon, HTTP status code, HTTP response headers (array of strings)
     */
    public function couponsIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopCoupon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation couponsIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdGetAsync($id, $context = null)
    {
        return $this->couponsIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation couponsIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'couponsIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function couponsIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling couponsIdGet'
            );
        }

        $resourcePath = '/coupons/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation couponsIdPatch
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopCoupon
     */
    public function couponsIdPatch($body, $id)
    {
        list($response) = $this->couponsIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation couponsIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopCoupon, HTTP status code, HTTP response headers (array of strings)
     */
    public function couponsIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopCoupon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation couponsIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdPatchAsync($body, $id)
    {
        return $this->couponsIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation couponsIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'couponsIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function couponsIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling couponsIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling couponsIdPatch'
            );
        }

        $resourcePath = '/coupons/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation couponsIdPost
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopCoupon
     */
    public function couponsIdPost($body, $id)
    {
        list($response) = $this->couponsIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation couponsIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopCoupon, HTTP status code, HTTP response headers (array of strings)
     */
    public function couponsIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopCoupon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation couponsIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdPostAsync($body, $id)
    {
        return $this->couponsIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation couponsIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'couponsIdPost'
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function couponsIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling couponsIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling couponsIdPost'
            );
        }

        $resourcePath = '/coupons/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation couponsIdPut
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopCoupon
     */
    public function couponsIdPut($body, $id)
    {
        list($response) = $this->couponsIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation couponsIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopCoupon, HTTP status code, HTTP response headers (array of strings)
     */
    public function couponsIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopCoupon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation couponsIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdPutAsync($body, $id)
    {
        return $this->couponsIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation couponsIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'couponsIdPut'
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function couponsIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling couponsIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling couponsIdPut'
            );
        }

        $resourcePath = '/coupons/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation couponsPost
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopCoupon
     */
    public function couponsPost($body)
    {
        list($response) = $this->couponsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation couponsPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopCoupon, HTTP status code, HTTP response headers (array of strings)
     */
    public function couponsPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopCoupon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation couponsPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsPostAsync($body)
    {
        return $this->couponsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation couponsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function couponsPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ShopCoupon';
        $request = $this->couponsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'couponsPost'
     *
     * @param  \WooCommerce\Client\Model\ShopCoupon1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function couponsPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling couponsPost'
            );
        }

        $resourcePath = '/coupons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersCustomerIdDownloadsGet
     *
     * @param  int $customer_id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\CustomerDownload[]
     */
    public function customersCustomerIdDownloadsGet($customer_id, $context = null)
    {
        list($response) = $this->customersCustomerIdDownloadsGetWithHttpInfo($customer_id, $context);
        return $response;
    }

    /**
     * Operation customersCustomerIdDownloadsGetWithHttpInfo
     *
     * @param  int $customer_id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\CustomerDownload[], HTTP status code, HTTP response headers (array of strings)
     */
    public function customersCustomerIdDownloadsGetWithHttpInfo($customer_id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\CustomerDownload[]';
        $request = $this->customersCustomerIdDownloadsGetRequest($customer_id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\CustomerDownload[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersCustomerIdDownloadsGetAsync
     *
     * 
     *
     * @param  int $customer_id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersCustomerIdDownloadsGetAsync($customer_id, $context = null)
    {
        return $this->customersCustomerIdDownloadsGetAsyncWithHttpInfo($customer_id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersCustomerIdDownloadsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $customer_id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersCustomerIdDownloadsGetAsyncWithHttpInfo($customer_id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\CustomerDownload[]';
        $request = $this->customersCustomerIdDownloadsGetRequest($customer_id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersCustomerIdDownloadsGet'
     *
     * @param  int $customer_id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customersCustomerIdDownloadsGetRequest($customer_id, $context = null)
    {
        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling customersCustomerIdDownloadsGet'
            );
        }

        $resourcePath = '/customers/{customer_id}/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customer_id' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $email Limit result set to resources with a specific email. (optional)
     * @param  string $role Limit result set to resources with a specific role. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Customer[]
     */
    public function customersGet($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $email = null, $role = null)
    {
        list($response) = $this->customersGetWithHttpInfo($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $email, $role);
        return $response;
    }

    /**
     * Operation customersGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $email Limit result set to resources with a specific email. (optional)
     * @param  string $role Limit result set to resources with a specific role. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Customer[], HTTP status code, HTTP response headers (array of strings)
     */
    public function customersGetWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $email = null, $role = null)
    {
        $returnType = '\WooCommerce\Client\Model\Customer[]';
        $request = $this->customersGetRequest($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $email, $role);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Customer[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $email Limit result set to resources with a specific email. (optional)
     * @param  string $role Limit result set to resources with a specific role. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersGetAsync($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $email = null, $role = null)
    {
        return $this->customersGetAsyncWithHttpInfo($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $email, $role)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $email Limit result set to resources with a specific email. (optional)
     * @param  string $role Limit result set to resources with a specific role. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $email = null, $role = null)
    {
        $returnType = '\WooCommerce\Client\Model\Customer[]';
        $request = $this->customersGetRequest($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $email, $role);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $email Limit result set to resources with a specific email. (optional)
     * @param  string $role Limit result set to resources with a specific role. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customersGetRequest($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $email = null, $role = null)
    {

        $resourcePath = '/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email, 'email');
        }
        // query params
        if ($role !== null) {
            $queryParams['role'] = ObjectSerializer::toQueryValue($role, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     * @param  int $reassign ID to reassign posts to. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Customer
     */
    public function customersIdDelete($id, $force = null, $reassign = null)
    {
        list($response) = $this->customersIdDeleteWithHttpInfo($id, $force, $reassign);
        return $response;
    }

    /**
     * Operation customersIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     * @param  int $reassign ID to reassign posts to. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersIdDeleteWithHttpInfo($id, $force = null, $reassign = null)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdDeleteRequest($id, $force, $reassign);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     * @param  int $reassign ID to reassign posts to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdDeleteAsync($id, $force = null, $reassign = null)
    {
        return $this->customersIdDeleteAsyncWithHttpInfo($id, $force, $reassign)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     * @param  int $reassign ID to reassign posts to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdDeleteAsyncWithHttpInfo($id, $force = null, $reassign = null)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdDeleteRequest($id, $force, $reassign);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     * @param  int $reassign ID to reassign posts to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customersIdDeleteRequest($id, $force = null, $reassign = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling customersIdDelete'
            );
        }

        $resourcePath = '/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }
        // query params
        if ($reassign !== null) {
            $queryParams['reassign'] = ObjectSerializer::toQueryValue($reassign, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Customer
     */
    public function customersIdGet($id, $context = null)
    {
        list($response) = $this->customersIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation customersIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdGetAsync($id, $context = null)
    {
        return $this->customersIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customersIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling customersIdGet'
            );
        }

        $resourcePath = '/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersIdPatch
     *
     * @param  \WooCommerce\Client\Model\Customer4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Customer
     */
    public function customersIdPatch($body, $id)
    {
        list($response) = $this->customersIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation customersIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Customer4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Customer4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdPatchAsync($body, $id)
    {
        return $this->customersIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Customer4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersIdPatch'
     *
     * @param  \WooCommerce\Client\Model\Customer4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customersIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling customersIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling customersIdPatch'
            );
        }

        $resourcePath = '/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersIdPost
     *
     * @param  \WooCommerce\Client\Model\Customer3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Customer
     */
    public function customersIdPost($body, $id)
    {
        list($response) = $this->customersIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation customersIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Customer3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Customer3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdPostAsync($body, $id)
    {
        return $this->customersIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Customer3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersIdPost'
     *
     * @param  \WooCommerce\Client\Model\Customer3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customersIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling customersIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling customersIdPost'
            );
        }

        $resourcePath = '/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersIdPut
     *
     * @param  \WooCommerce\Client\Model\Customer2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Customer
     */
    public function customersIdPut($body, $id)
    {
        list($response) = $this->customersIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation customersIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Customer2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Customer2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdPutAsync($body, $id)
    {
        return $this->customersIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Customer2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersIdPut'
     *
     * @param  \WooCommerce\Client\Model\Customer2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customersIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling customersIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling customersIdPut'
            );
        }

        $resourcePath = '/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersPost
     *
     * @param  \WooCommerce\Client\Model\Customer1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Customer
     */
    public function customersPost($body)
    {
        list($response) = $this->customersPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation customersPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Customer1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Customer1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersPostAsync($body)
    {
        return $this->customersPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Customer1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\Customer';
        $request = $this->customersPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersPost'
     *
     * @param  \WooCommerce\Client\Model\Customer1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customersPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling customersPost'
            );
        }

        $resourcePath = '/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dataContinentsGet
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\DataContinents[]
     */
    public function dataContinentsGet()
    {
        list($response) = $this->dataContinentsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation dataContinentsGetWithHttpInfo
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\DataContinents[], HTTP status code, HTTP response headers (array of strings)
     */
    public function dataContinentsGetWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataContinents[]';
        $request = $this->dataContinentsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\DataContinents[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dataContinentsGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataContinentsGetAsync()
    {
        return $this->dataContinentsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dataContinentsGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataContinentsGetAsyncWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataContinents[]';
        $request = $this->dataContinentsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dataContinentsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dataContinentsGetRequest()
    {

        $resourcePath = '/data/continents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dataContinentsLocationGet
     *
     * @param  string $location 2 character continent code. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\DataContinents
     */
    public function dataContinentsLocationGet($location)
    {
        list($response) = $this->dataContinentsLocationGetWithHttpInfo($location);
        return $response;
    }

    /**
     * Operation dataContinentsLocationGetWithHttpInfo
     *
     * @param  string $location 2 character continent code. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\DataContinents, HTTP status code, HTTP response headers (array of strings)
     */
    public function dataContinentsLocationGetWithHttpInfo($location)
    {
        $returnType = '\WooCommerce\Client\Model\DataContinents';
        $request = $this->dataContinentsLocationGetRequest($location);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\DataContinents',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dataContinentsLocationGetAsync
     *
     * 
     *
     * @param  string $location 2 character continent code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataContinentsLocationGetAsync($location)
    {
        return $this->dataContinentsLocationGetAsyncWithHttpInfo($location)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dataContinentsLocationGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $location 2 character continent code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataContinentsLocationGetAsyncWithHttpInfo($location)
    {
        $returnType = '\WooCommerce\Client\Model\DataContinents';
        $request = $this->dataContinentsLocationGetRequest($location);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dataContinentsLocationGet'
     *
     * @param  string $location 2 character continent code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dataContinentsLocationGetRequest($location)
    {
        // verify the required parameter 'location' is set
        if ($location === null || (is_array($location) && count($location) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location when calling dataContinentsLocationGet'
            );
        }

        $resourcePath = '/data/continents/{location}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location !== null) {
            $resourcePath = str_replace(
                '{' . 'location' . '}',
                ObjectSerializer::toPathValue($location),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dataCountriesGet
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\DataCountries[]
     */
    public function dataCountriesGet()
    {
        list($response) = $this->dataCountriesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation dataCountriesGetWithHttpInfo
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\DataCountries[], HTTP status code, HTTP response headers (array of strings)
     */
    public function dataCountriesGetWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataCountries[]';
        $request = $this->dataCountriesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\DataCountries[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dataCountriesGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCountriesGetAsync()
    {
        return $this->dataCountriesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dataCountriesGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCountriesGetAsyncWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataCountries[]';
        $request = $this->dataCountriesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dataCountriesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dataCountriesGetRequest()
    {

        $resourcePath = '/data/countries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dataCountriesLocationGet
     *
     * @param  string $location ISO3166 alpha-2 country code. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\DataCountries
     */
    public function dataCountriesLocationGet($location)
    {
        list($response) = $this->dataCountriesLocationGetWithHttpInfo($location);
        return $response;
    }

    /**
     * Operation dataCountriesLocationGetWithHttpInfo
     *
     * @param  string $location ISO3166 alpha-2 country code. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\DataCountries, HTTP status code, HTTP response headers (array of strings)
     */
    public function dataCountriesLocationGetWithHttpInfo($location)
    {
        $returnType = '\WooCommerce\Client\Model\DataCountries';
        $request = $this->dataCountriesLocationGetRequest($location);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\DataCountries',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dataCountriesLocationGetAsync
     *
     * 
     *
     * @param  string $location ISO3166 alpha-2 country code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCountriesLocationGetAsync($location)
    {
        return $this->dataCountriesLocationGetAsyncWithHttpInfo($location)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dataCountriesLocationGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $location ISO3166 alpha-2 country code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCountriesLocationGetAsyncWithHttpInfo($location)
    {
        $returnType = '\WooCommerce\Client\Model\DataCountries';
        $request = $this->dataCountriesLocationGetRequest($location);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dataCountriesLocationGet'
     *
     * @param  string $location ISO3166 alpha-2 country code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dataCountriesLocationGetRequest($location)
    {
        // verify the required parameter 'location' is set
        if ($location === null || (is_array($location) && count($location) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location when calling dataCountriesLocationGet'
            );
        }

        $resourcePath = '/data/countries/{location}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location !== null) {
            $resourcePath = str_replace(
                '{' . 'location' . '}',
                ObjectSerializer::toPathValue($location),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dataCurrenciesCurrencyGet
     *
     * @param  string $currency ISO4217 currency code. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\DataCurrencies
     */
    public function dataCurrenciesCurrencyGet($currency)
    {
        list($response) = $this->dataCurrenciesCurrencyGetWithHttpInfo($currency);
        return $response;
    }

    /**
     * Operation dataCurrenciesCurrencyGetWithHttpInfo
     *
     * @param  string $currency ISO4217 currency code. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\DataCurrencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function dataCurrenciesCurrencyGetWithHttpInfo($currency)
    {
        $returnType = '\WooCommerce\Client\Model\DataCurrencies';
        $request = $this->dataCurrenciesCurrencyGetRequest($currency);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\DataCurrencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dataCurrenciesCurrencyGetAsync
     *
     * 
     *
     * @param  string $currency ISO4217 currency code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCurrenciesCurrencyGetAsync($currency)
    {
        return $this->dataCurrenciesCurrencyGetAsyncWithHttpInfo($currency)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dataCurrenciesCurrencyGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $currency ISO4217 currency code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCurrenciesCurrencyGetAsyncWithHttpInfo($currency)
    {
        $returnType = '\WooCommerce\Client\Model\DataCurrencies';
        $request = $this->dataCurrenciesCurrencyGetRequest($currency);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dataCurrenciesCurrencyGet'
     *
     * @param  string $currency ISO4217 currency code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dataCurrenciesCurrencyGetRequest($currency)
    {
        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling dataCurrenciesCurrencyGet'
            );
        }

        $resourcePath = '/data/currencies/{currency}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($currency !== null) {
            $resourcePath = str_replace(
                '{' . 'currency' . '}',
                ObjectSerializer::toPathValue($currency),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dataCurrenciesCurrentGet
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\DataCurrencies
     */
    public function dataCurrenciesCurrentGet()
    {
        list($response) = $this->dataCurrenciesCurrentGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation dataCurrenciesCurrentGetWithHttpInfo
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\DataCurrencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function dataCurrenciesCurrentGetWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataCurrencies';
        $request = $this->dataCurrenciesCurrentGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\DataCurrencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dataCurrenciesCurrentGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCurrenciesCurrentGetAsync()
    {
        return $this->dataCurrenciesCurrentGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dataCurrenciesCurrentGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCurrenciesCurrentGetAsyncWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataCurrencies';
        $request = $this->dataCurrenciesCurrentGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dataCurrenciesCurrentGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dataCurrenciesCurrentGetRequest()
    {

        $resourcePath = '/data/currencies/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dataCurrenciesGet
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\DataCurrencies[]
     */
    public function dataCurrenciesGet()
    {
        list($response) = $this->dataCurrenciesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation dataCurrenciesGetWithHttpInfo
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\DataCurrencies[], HTTP status code, HTTP response headers (array of strings)
     */
    public function dataCurrenciesGetWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataCurrencies[]';
        $request = $this->dataCurrenciesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\DataCurrencies[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dataCurrenciesGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCurrenciesGetAsync()
    {
        return $this->dataCurrenciesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dataCurrenciesGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataCurrenciesGetAsyncWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataCurrencies[]';
        $request = $this->dataCurrenciesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dataCurrenciesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dataCurrenciesGetRequest()
    {

        $resourcePath = '/data/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dataGet
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\DataIndex
     */
    public function dataGet()
    {
        list($response) = $this->dataGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation dataGetWithHttpInfo
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\DataIndex, HTTP status code, HTTP response headers (array of strings)
     */
    public function dataGetWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataIndex';
        $request = $this->dataGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\DataIndex',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dataGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataGetAsync()
    {
        return $this->dataGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dataGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dataGetAsyncWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\DataIndex';
        $request = $this->dataGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dataGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dataGetRequest()
    {

        $resourcePath = '/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string[] $status Limit result set to orders which have specific statuses. (optional)
     * @param  int $customer Limit result set to orders assigned a specific customer. (optional)
     * @param  int $product Limit result set to orders assigned a specific product. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrder[]
     */
    public function ordersGet($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $status = null, $customer = null, $product = null, $dp = null)
    {
        list($response) = $this->ordersGetWithHttpInfo($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $status, $customer, $product, $dp);
        return $response;
    }

    /**
     * Operation ordersGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string[] $status Limit result set to orders which have specific statuses. (optional)
     * @param  int $customer Limit result set to orders assigned a specific customer. (optional)
     * @param  int $product Limit result set to orders assigned a specific product. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersGetWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $status = null, $customer = null, $product = null, $dp = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder[]';
        $request = $this->ordersGetRequest($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $status, $customer, $product, $dp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string[] $status Limit result set to orders which have specific statuses. (optional)
     * @param  int $customer Limit result set to orders assigned a specific customer. (optional)
     * @param  int $product Limit result set to orders assigned a specific product. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersGetAsync($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $status = null, $customer = null, $product = null, $dp = null)
    {
        return $this->ordersGetAsyncWithHttpInfo($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $status, $customer, $product, $dp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string[] $status Limit result set to orders which have specific statuses. (optional)
     * @param  int $customer Limit result set to orders assigned a specific customer. (optional)
     * @param  int $product Limit result set to orders assigned a specific product. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $status = null, $customer = null, $product = null, $dp = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder[]';
        $request = $this->ordersGetRequest($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $status, $customer, $product, $dp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string[] $status Limit result set to orders which have specific statuses. (optional)
     * @param  int $customer Limit result set to orders assigned a specific customer. (optional)
     * @param  int $product Limit result set to orders assigned a specific product. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersGetRequest($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $status = null, $customer = null, $product = null, $dp = null)
    {

        $resourcePath = '/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if ($after !== null) {
            $queryParams['after'] = ObjectSerializer::toQueryValue($after, 'string');
        }
        // query params
        if ($before !== null) {
            $queryParams['before'] = ObjectSerializer::toQueryValue($before, 'string');
        }
        // query params
        if ($modified_after !== null) {
            $queryParams['modified_after'] = ObjectSerializer::toQueryValue($modified_after, 'string');
        }
        // query params
        if ($modified_before !== null) {
            $queryParams['modified_before'] = ObjectSerializer::toQueryValue($modified_before, 'string');
        }
        // query params
        if ($dates_are_gmt !== null) {
            $queryParams['dates_are_gmt'] = ObjectSerializer::toQueryValue($dates_are_gmt, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if (is_array($parent)) {
            $parent = ObjectSerializer::serializeCollection($parent, 'multi', true);
        }
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent, null);
        }
        // query params
        if (is_array($parent_exclude)) {
            $parent_exclude = ObjectSerializer::serializeCollection($parent_exclude, 'multi', true);
        }
        if ($parent_exclude !== null) {
            $queryParams['parent_exclude'] = ObjectSerializer::toQueryValue($parent_exclude, null);
        }
        // query params
        if (is_array($status)) {
            $status = ObjectSerializer::serializeCollection($status, 'multi', true);
        }
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if ($product !== null) {
            $queryParams['product'] = ObjectSerializer::toQueryValue($product, null);
        }
        // query params
        if ($dp !== null) {
            $queryParams['dp'] = ObjectSerializer::toQueryValue($dp, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrder
     */
    public function ordersIdDelete($id, $force = null)
    {
        list($response) = $this->ordersIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation ordersIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdDeleteAsync($id, $force = null)
    {
        return $this->ordersIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersIdDelete'
            );
        }

        $resourcePath = '/orders/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrder
     */
    public function ordersIdGet($id, $context = null)
    {
        list($response) = $this->ordersIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation ordersIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdGetAsync($id, $context = null)
    {
        return $this->ordersIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersIdGet'
            );
        }

        $resourcePath = '/orders/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersIdPatch
     *
     * @param  \WooCommerce\Client\Model\ShopOrder4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrder
     */
    public function ordersIdPatch($body, $id)
    {
        list($response) = $this->ordersIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation ordersIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShopOrder4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrder4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdPatchAsync($body, $id)
    {
        return $this->ordersIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrder4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ShopOrder4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling ordersIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersIdPatch'
            );
        }

        $resourcePath = '/orders/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersIdPost
     *
     * @param  \WooCommerce\Client\Model\ShopOrder3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrder
     */
    public function ordersIdPost($body, $id)
    {
        list($response) = $this->ordersIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation ordersIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShopOrder3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrder3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdPostAsync($body, $id)
    {
        return $this->ordersIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrder3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersIdPost'
     *
     * @param  \WooCommerce\Client\Model\ShopOrder3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling ordersIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersIdPost'
            );
        }

        $resourcePath = '/orders/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersIdPut
     *
     * @param  \WooCommerce\Client\Model\ShopOrder2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrder
     */
    public function ordersIdPut($body, $id)
    {
        list($response) = $this->ordersIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation ordersIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShopOrder2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrder2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdPutAsync($body, $id)
    {
        return $this->ordersIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrder2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersIdPut'
     *
     * @param  \WooCommerce\Client\Model\ShopOrder2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling ordersIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersIdPut'
            );
        }

        $resourcePath = '/orders/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdNotesGet
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $type Limit result to customers or internal notes. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\OrderNote[]
     */
    public function ordersOrderIdNotesGet($order_id, $context = null, $type = null)
    {
        list($response) = $this->ordersOrderIdNotesGetWithHttpInfo($order_id, $context, $type);
        return $response;
    }

    /**
     * Operation ordersOrderIdNotesGetWithHttpInfo
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $type Limit result to customers or internal notes. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\OrderNote[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdNotesGetWithHttpInfo($order_id, $context = null, $type = null)
    {
        $returnType = '\WooCommerce\Client\Model\OrderNote[]';
        $request = $this->ordersOrderIdNotesGetRequest($order_id, $context, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\OrderNote[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdNotesGetAsync
     *
     * 
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $type Limit result to customers or internal notes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdNotesGetAsync($order_id, $context = null, $type = null)
    {
        return $this->ordersOrderIdNotesGetAsyncWithHttpInfo($order_id, $context, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdNotesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $type Limit result to customers or internal notes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdNotesGetAsyncWithHttpInfo($order_id, $context = null, $type = null)
    {
        $returnType = '\WooCommerce\Client\Model\OrderNote[]';
        $request = $this->ordersOrderIdNotesGetRequest($order_id, $context, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdNotesGet'
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $type Limit result to customers or internal notes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersOrderIdNotesGetRequest($order_id, $context = null, $type = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdNotesGet'
            );
        }

        $resourcePath = '/orders/{order_id}/notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdNotesIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\OrderNote
     */
    public function ordersOrderIdNotesIdDelete($id, $order_id, $force = null)
    {
        list($response) = $this->ordersOrderIdNotesIdDeleteWithHttpInfo($id, $order_id, $force);
        return $response;
    }

    /**
     * Operation ordersOrderIdNotesIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\OrderNote, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdNotesIdDeleteWithHttpInfo($id, $order_id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\OrderNote';
        $request = $this->ordersOrderIdNotesIdDeleteRequest($id, $order_id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\OrderNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdNotesIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdNotesIdDeleteAsync($id, $order_id, $force = null)
    {
        return $this->ordersOrderIdNotesIdDeleteAsyncWithHttpInfo($id, $order_id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdNotesIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdNotesIdDeleteAsyncWithHttpInfo($id, $order_id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\OrderNote';
        $request = $this->ordersOrderIdNotesIdDeleteRequest($id, $order_id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdNotesIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersOrderIdNotesIdDeleteRequest($id, $order_id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersOrderIdNotesIdDelete'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdNotesIdDelete'
            );
        }

        $resourcePath = '/orders/{order_id}/notes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdNotesIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\OrderNote
     */
    public function ordersOrderIdNotesIdGet($id, $order_id, $context = null)
    {
        list($response) = $this->ordersOrderIdNotesIdGetWithHttpInfo($id, $order_id, $context);
        return $response;
    }

    /**
     * Operation ordersOrderIdNotesIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\OrderNote, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdNotesIdGetWithHttpInfo($id, $order_id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\OrderNote';
        $request = $this->ordersOrderIdNotesIdGetRequest($id, $order_id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\OrderNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdNotesIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdNotesIdGetAsync($id, $order_id, $context = null)
    {
        return $this->ordersOrderIdNotesIdGetAsyncWithHttpInfo($id, $order_id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdNotesIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdNotesIdGetAsyncWithHttpInfo($id, $order_id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\OrderNote';
        $request = $this->ordersOrderIdNotesIdGetRequest($id, $order_id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdNotesIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersOrderIdNotesIdGetRequest($id, $order_id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersOrderIdNotesIdGet'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdNotesIdGet'
            );
        }

        $resourcePath = '/orders/{order_id}/notes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdNotesPost
     *
     * @param  \WooCommerce\Client\Model\OrderNote1 $body body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\OrderNote
     */
    public function ordersOrderIdNotesPost($body, $order_id)
    {
        list($response) = $this->ordersOrderIdNotesPostWithHttpInfo($body, $order_id);
        return $response;
    }

    /**
     * Operation ordersOrderIdNotesPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\OrderNote1 $body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\OrderNote, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdNotesPostWithHttpInfo($body, $order_id)
    {
        $returnType = '\WooCommerce\Client\Model\OrderNote';
        $request = $this->ordersOrderIdNotesPostRequest($body, $order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\OrderNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdNotesPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\OrderNote1 $body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdNotesPostAsync($body, $order_id)
    {
        return $this->ordersOrderIdNotesPostAsyncWithHttpInfo($body, $order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdNotesPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\OrderNote1 $body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdNotesPostAsyncWithHttpInfo($body, $order_id)
    {
        $returnType = '\WooCommerce\Client\Model\OrderNote';
        $request = $this->ordersOrderIdNotesPostRequest($body, $order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdNotesPost'
     *
     * @param  \WooCommerce\Client\Model\OrderNote1 $body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersOrderIdNotesPostRequest($body, $order_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling ordersOrderIdNotesPost'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdNotesPost'
            );
        }

        $resourcePath = '/orders/{order_id}/notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdRefundsGet
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrderRefund[]
     */
    public function ordersOrderIdRefundsGet($order_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $dp = null)
    {
        list($response) = $this->ordersOrderIdRefundsGetWithHttpInfo($order_id, $context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $dp);
        return $response;
    }

    /**
     * Operation ordersOrderIdRefundsGetWithHttpInfo
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrderRefund[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdRefundsGetWithHttpInfo($order_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $dp = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrderRefund[]';
        $request = $this->ordersOrderIdRefundsGetRequest($order_id, $context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $dp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrderRefund[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdRefundsGetAsync
     *
     * 
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdRefundsGetAsync($order_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $dp = null)
    {
        return $this->ordersOrderIdRefundsGetAsyncWithHttpInfo($order_id, $context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $dp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdRefundsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdRefundsGetAsyncWithHttpInfo($order_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $dp = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrderRefund[]';
        $request = $this->ordersOrderIdRefundsGetRequest($order_id, $context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $dp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdRefundsGet'
     *
     * @param  int $order_id The order ID. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  int $dp Number of decimal points to use in each resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersOrderIdRefundsGetRequest($order_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $dp = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdRefundsGet'
            );
        }

        $resourcePath = '/orders/{order_id}/refunds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if ($after !== null) {
            $queryParams['after'] = ObjectSerializer::toQueryValue($after, 'string');
        }
        // query params
        if ($before !== null) {
            $queryParams['before'] = ObjectSerializer::toQueryValue($before, 'string');
        }
        // query params
        if ($modified_after !== null) {
            $queryParams['modified_after'] = ObjectSerializer::toQueryValue($modified_after, 'string');
        }
        // query params
        if ($modified_before !== null) {
            $queryParams['modified_before'] = ObjectSerializer::toQueryValue($modified_before, 'string');
        }
        // query params
        if ($dates_are_gmt !== null) {
            $queryParams['dates_are_gmt'] = ObjectSerializer::toQueryValue($dates_are_gmt, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if (is_array($parent)) {
            $parent = ObjectSerializer::serializeCollection($parent, 'multi', true);
        }
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent, null);
        }
        // query params
        if (is_array($parent_exclude)) {
            $parent_exclude = ObjectSerializer::serializeCollection($parent_exclude, 'multi', true);
        }
        if ($parent_exclude !== null) {
            $queryParams['parent_exclude'] = ObjectSerializer::toQueryValue($parent_exclude, null);
        }
        // query params
        if ($dp !== null) {
            $queryParams['dp'] = ObjectSerializer::toQueryValue($dp, null);
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdRefundsIdDelete
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrderRefund
     */
    public function ordersOrderIdRefundsIdDelete($order_id, $id, $force = null)
    {
        list($response) = $this->ordersOrderIdRefundsIdDeleteWithHttpInfo($order_id, $id, $force);
        return $response;
    }

    /**
     * Operation ordersOrderIdRefundsIdDeleteWithHttpInfo
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrderRefund, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdRefundsIdDeleteWithHttpInfo($order_id, $id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrderRefund';
        $request = $this->ordersOrderIdRefundsIdDeleteRequest($order_id, $id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrderRefund',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdRefundsIdDeleteAsync
     *
     * 
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdRefundsIdDeleteAsync($order_id, $id, $force = null)
    {
        return $this->ordersOrderIdRefundsIdDeleteAsyncWithHttpInfo($order_id, $id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdRefundsIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdRefundsIdDeleteAsyncWithHttpInfo($order_id, $id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrderRefund';
        $request = $this->ordersOrderIdRefundsIdDeleteRequest($order_id, $id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdRefundsIdDelete'
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersOrderIdRefundsIdDeleteRequest($order_id, $id, $force = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdRefundsIdDelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersOrderIdRefundsIdDelete'
            );
        }

        $resourcePath = '/orders/{order_id}/refunds/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdRefundsIdGet
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrderRefund
     */
    public function ordersOrderIdRefundsIdGet($order_id, $id, $context = null)
    {
        list($response) = $this->ordersOrderIdRefundsIdGetWithHttpInfo($order_id, $id, $context);
        return $response;
    }

    /**
     * Operation ordersOrderIdRefundsIdGetWithHttpInfo
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrderRefund, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdRefundsIdGetWithHttpInfo($order_id, $id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrderRefund';
        $request = $this->ordersOrderIdRefundsIdGetRequest($order_id, $id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrderRefund',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdRefundsIdGetAsync
     *
     * 
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdRefundsIdGetAsync($order_id, $id, $context = null)
    {
        return $this->ordersOrderIdRefundsIdGetAsyncWithHttpInfo($order_id, $id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdRefundsIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdRefundsIdGetAsyncWithHttpInfo($order_id, $id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrderRefund';
        $request = $this->ordersOrderIdRefundsIdGetRequest($order_id, $id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdRefundsIdGet'
     *
     * @param  int $order_id The order ID. (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersOrderIdRefundsIdGetRequest($order_id, $id, $context = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdRefundsIdGet'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersOrderIdRefundsIdGet'
            );
        }

        $resourcePath = '/orders/{order_id}/refunds/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdRefundsPost
     *
     * @param  \WooCommerce\Client\Model\ShopOrderRefund1 $body body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrderRefund
     */
    public function ordersOrderIdRefundsPost($body, $order_id)
    {
        list($response) = $this->ordersOrderIdRefundsPostWithHttpInfo($body, $order_id);
        return $response;
    }

    /**
     * Operation ordersOrderIdRefundsPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShopOrderRefund1 $body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrderRefund, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdRefundsPostWithHttpInfo($body, $order_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrderRefund';
        $request = $this->ordersOrderIdRefundsPostRequest($body, $order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrderRefund',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdRefundsPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrderRefund1 $body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdRefundsPostAsync($body, $order_id)
    {
        return $this->ordersOrderIdRefundsPostAsyncWithHttpInfo($body, $order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdRefundsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrderRefund1 $body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdRefundsPostAsyncWithHttpInfo($body, $order_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrderRefund';
        $request = $this->ordersOrderIdRefundsPostRequest($body, $order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdRefundsPost'
     *
     * @param  \WooCommerce\Client\Model\ShopOrderRefund1 $body (required)
     * @param  int $order_id The order ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersOrderIdRefundsPostRequest($body, $order_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling ordersOrderIdRefundsPost'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdRefundsPost'
            );
        }

        $resourcePath = '/orders/{order_id}/refunds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersPost
     *
     * @param  \WooCommerce\Client\Model\ShopOrder1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShopOrder
     */
    public function ordersPost($body)
    {
        list($response) = $this->ordersPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation ordersPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShopOrder1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShopOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShopOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrder1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersPostAsync($body)
    {
        return $this->ordersPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShopOrder1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ShopOrder';
        $request = $this->ordersPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersPost'
     *
     * @param  \WooCommerce\Client\Model\ShopOrder1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ordersPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling ordersPost'
            );
        }

        $resourcePath = '/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentGatewaysGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\PaymentGateway[]
     */
    public function paymentGatewaysGet($context = null)
    {
        list($response) = $this->paymentGatewaysGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation paymentGatewaysGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\PaymentGateway[], HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentGatewaysGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway[]';
        $request = $this->paymentGatewaysGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\PaymentGateway[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation paymentGatewaysGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysGetAsync($context = null)
    {
        return $this->paymentGatewaysGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentGatewaysGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway[]';
        $request = $this->paymentGatewaysGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentGatewaysGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function paymentGatewaysGetRequest($context = null)
    {

        $resourcePath = '/payment_gateways';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentGatewaysIdGet
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\PaymentGateway
     */
    public function paymentGatewaysIdGet($id, $context = null)
    {
        list($response) = $this->paymentGatewaysIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation paymentGatewaysIdGetWithHttpInfo
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\PaymentGateway, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentGatewaysIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway';
        $request = $this->paymentGatewaysIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\PaymentGateway',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation paymentGatewaysIdGetAsync
     *
     * 
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysIdGetAsync($id, $context = null)
    {
        return $this->paymentGatewaysIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentGatewaysIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway';
        $request = $this->paymentGatewaysIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentGatewaysIdGet'
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function paymentGatewaysIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling paymentGatewaysIdGet'
            );
        }

        $resourcePath = '/payment_gateways/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentGatewaysIdPatch
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway3 $body body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\PaymentGateway
     */
    public function paymentGatewaysIdPatch($body, $id)
    {
        list($response) = $this->paymentGatewaysIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation paymentGatewaysIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway3 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\PaymentGateway, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentGatewaysIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway';
        $request = $this->paymentGatewaysIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\PaymentGateway',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation paymentGatewaysIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway3 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysIdPatchAsync($body, $id)
    {
        return $this->paymentGatewaysIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentGatewaysIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway3 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway';
        $request = $this->paymentGatewaysIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentGatewaysIdPatch'
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway3 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function paymentGatewaysIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling paymentGatewaysIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling paymentGatewaysIdPatch'
            );
        }

        $resourcePath = '/payment_gateways/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentGatewaysIdPost
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway2 $body body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\PaymentGateway
     */
    public function paymentGatewaysIdPost($body, $id)
    {
        list($response) = $this->paymentGatewaysIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation paymentGatewaysIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway2 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\PaymentGateway, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentGatewaysIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway';
        $request = $this->paymentGatewaysIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\PaymentGateway',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation paymentGatewaysIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway2 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysIdPostAsync($body, $id)
    {
        return $this->paymentGatewaysIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentGatewaysIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway2 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway';
        $request = $this->paymentGatewaysIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentGatewaysIdPost'
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway2 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function paymentGatewaysIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling paymentGatewaysIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling paymentGatewaysIdPost'
            );
        }

        $resourcePath = '/payment_gateways/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentGatewaysIdPut
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway1 $body body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\PaymentGateway
     */
    public function paymentGatewaysIdPut($body, $id)
    {
        list($response) = $this->paymentGatewaysIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation paymentGatewaysIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway1 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\PaymentGateway, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentGatewaysIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway';
        $request = $this->paymentGatewaysIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\PaymentGateway',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation paymentGatewaysIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway1 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysIdPutAsync($body, $id)
    {
        return $this->paymentGatewaysIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentGatewaysIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway1 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentGatewaysIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\PaymentGateway';
        $request = $this->paymentGatewaysIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentGatewaysIdPut'
     *
     * @param  \WooCommerce\Client\Model\PaymentGateway1 $body (required)
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function paymentGatewaysIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling paymentGatewaysIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling paymentGatewaysIdPut'
            );
        }

        $resourcePath = '/payment_gateways/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesAttributeIdTermsGet
     *
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttributeTerm[]
     */
    public function productsAttributesAttributeIdTermsGet($attribute_id, $context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        list($response) = $this->productsAttributesAttributeIdTermsGetWithHttpInfo($attribute_id, $context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);
        return $response;
    }

    /**
     * Operation productsAttributesAttributeIdTermsGetWithHttpInfo
     *
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttributeTerm[], HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesAttributeIdTermsGetWithHttpInfo($attribute_id, $context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm[]';
        $request = $this->productsAttributesAttributeIdTermsGetRequest($attribute_id, $context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttributeTerm[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesAttributeIdTermsGetAsync
     *
     * 
     *
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsGetAsync($attribute_id, $context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        return $this->productsAttributesAttributeIdTermsGetAsyncWithHttpInfo($attribute_id, $context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesAttributeIdTermsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsGetAsyncWithHttpInfo($attribute_id, $context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm[]';
        $request = $this->productsAttributesAttributeIdTermsGetRequest($attribute_id, $context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesAttributeIdTermsGet'
     *
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesAttributeIdTermsGetRequest($attribute_id, $context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling productsAttributesAttributeIdTermsGet'
            );
        }

        $resourcePath = '/products/attributes/{attribute_id}/terms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if ($hide_empty !== null) {
            $queryParams['hide_empty'] = ObjectSerializer::toQueryValue($hide_empty, null);
        }
        // query params
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent, null);
        }
        // query params
        if ($product !== null) {
            $queryParams['product'] = ObjectSerializer::toQueryValue($product, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }

        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attribute_id' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttributeTerm
     */
    public function productsAttributesAttributeIdTermsIdDelete($id, $attribute_id, $force = null)
    {
        list($response) = $this->productsAttributesAttributeIdTermsIdDeleteWithHttpInfo($id, $attribute_id, $force);
        return $response;
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttributeTerm, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesAttributeIdTermsIdDeleteWithHttpInfo($id, $attribute_id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdDeleteRequest($id, $attribute_id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttributeTerm',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdDeleteAsync($id, $attribute_id, $force = null)
    {
        return $this->productsAttributesAttributeIdTermsIdDeleteAsyncWithHttpInfo($id, $attribute_id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdDeleteAsyncWithHttpInfo($id, $attribute_id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdDeleteRequest($id, $attribute_id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesAttributeIdTermsIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesAttributeIdTermsIdDeleteRequest($id, $attribute_id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesAttributeIdTermsIdDelete'
            );
        }
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling productsAttributesAttributeIdTermsIdDelete'
            );
        }

        $resourcePath = '/products/attributes/{attribute_id}/terms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attribute_id' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttributeTerm
     */
    public function productsAttributesAttributeIdTermsIdGet($id, $attribute_id, $context = null)
    {
        list($response) = $this->productsAttributesAttributeIdTermsIdGetWithHttpInfo($id, $attribute_id, $context);
        return $response;
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttributeTerm, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesAttributeIdTermsIdGetWithHttpInfo($id, $attribute_id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdGetRequest($id, $attribute_id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttributeTerm',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdGetAsync($id, $attribute_id, $context = null)
    {
        return $this->productsAttributesAttributeIdTermsIdGetAsyncWithHttpInfo($id, $attribute_id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdGetAsyncWithHttpInfo($id, $attribute_id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdGetRequest($id, $attribute_id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesAttributeIdTermsIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesAttributeIdTermsIdGetRequest($id, $attribute_id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesAttributeIdTermsIdGet'
            );
        }
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling productsAttributesAttributeIdTermsIdGet'
            );
        }

        $resourcePath = '/products/attributes/{attribute_id}/terms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attribute_id' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPatch
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttributeTerm
     */
    public function productsAttributesAttributeIdTermsIdPatch($body, $id, $attribute_id)
    {
        list($response) = $this->productsAttributesAttributeIdTermsIdPatchWithHttpInfo($body, $id, $attribute_id);
        return $response;
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttributeTerm, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesAttributeIdTermsIdPatchWithHttpInfo($body, $id, $attribute_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdPatchRequest($body, $id, $attribute_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttributeTerm',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdPatchAsync($body, $id, $attribute_id)
    {
        return $this->productsAttributesAttributeIdTermsIdPatchAsyncWithHttpInfo($body, $id, $attribute_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdPatchAsyncWithHttpInfo($body, $id, $attribute_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdPatchRequest($body, $id, $attribute_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesAttributeIdTermsIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesAttributeIdTermsIdPatchRequest($body, $id, $attribute_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsAttributesAttributeIdTermsIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesAttributeIdTermsIdPatch'
            );
        }
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling productsAttributesAttributeIdTermsIdPatch'
            );
        }

        $resourcePath = '/products/attributes/{attribute_id}/terms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attribute_id' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPost
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttributeTerm
     */
    public function productsAttributesAttributeIdTermsIdPost($body, $id, $attribute_id)
    {
        list($response) = $this->productsAttributesAttributeIdTermsIdPostWithHttpInfo($body, $id, $attribute_id);
        return $response;
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttributeTerm, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesAttributeIdTermsIdPostWithHttpInfo($body, $id, $attribute_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdPostRequest($body, $id, $attribute_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttributeTerm',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdPostAsync($body, $id, $attribute_id)
    {
        return $this->productsAttributesAttributeIdTermsIdPostAsyncWithHttpInfo($body, $id, $attribute_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdPostAsyncWithHttpInfo($body, $id, $attribute_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdPostRequest($body, $id, $attribute_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesAttributeIdTermsIdPost'
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesAttributeIdTermsIdPostRequest($body, $id, $attribute_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsAttributesAttributeIdTermsIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesAttributeIdTermsIdPost'
            );
        }
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling productsAttributesAttributeIdTermsIdPost'
            );
        }

        $resourcePath = '/products/attributes/{attribute_id}/terms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attribute_id' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPut
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttributeTerm
     */
    public function productsAttributesAttributeIdTermsIdPut($body, $id, $attribute_id)
    {
        list($response) = $this->productsAttributesAttributeIdTermsIdPutWithHttpInfo($body, $id, $attribute_id);
        return $response;
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttributeTerm, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesAttributeIdTermsIdPutWithHttpInfo($body, $id, $attribute_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdPutRequest($body, $id, $attribute_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttributeTerm',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdPutAsync($body, $id, $attribute_id)
    {
        return $this->productsAttributesAttributeIdTermsIdPutAsyncWithHttpInfo($body, $id, $attribute_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesAttributeIdTermsIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsIdPutAsyncWithHttpInfo($body, $id, $attribute_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsIdPutRequest($body, $id, $attribute_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesAttributeIdTermsIdPut'
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesAttributeIdTermsIdPutRequest($body, $id, $attribute_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsAttributesAttributeIdTermsIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesAttributeIdTermsIdPut'
            );
        }
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling productsAttributesAttributeIdTermsIdPut'
            );
        }

        $resourcePath = '/products/attributes/{attribute_id}/terms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attribute_id' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesAttributeIdTermsPost
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm1 $body body (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttributeTerm
     */
    public function productsAttributesAttributeIdTermsPost($body, $attribute_id)
    {
        list($response) = $this->productsAttributesAttributeIdTermsPostWithHttpInfo($body, $attribute_id);
        return $response;
    }

    /**
     * Operation productsAttributesAttributeIdTermsPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm1 $body (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttributeTerm, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesAttributeIdTermsPostWithHttpInfo($body, $attribute_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsPostRequest($body, $attribute_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttributeTerm',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesAttributeIdTermsPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm1 $body (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsPostAsync($body, $attribute_id)
    {
        return $this->productsAttributesAttributeIdTermsPostAsyncWithHttpInfo($body, $attribute_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesAttributeIdTermsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm1 $body (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesAttributeIdTermsPostAsyncWithHttpInfo($body, $attribute_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttributeTerm';
        $request = $this->productsAttributesAttributeIdTermsPostRequest($body, $attribute_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesAttributeIdTermsPost'
     *
     * @param  \WooCommerce\Client\Model\ProductAttributeTerm1 $body (required)
     * @param  int $attribute_id Unique identifier for the attribute of the terms. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesAttributeIdTermsPostRequest($body, $attribute_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsAttributesAttributeIdTermsPost'
            );
        }
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling productsAttributesAttributeIdTermsPost'
            );
        }

        $resourcePath = '/products/attributes/{attribute_id}/terms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attribute_id' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttribute[]
     */
    public function productsAttributesGet($context = null)
    {
        list($response) = $this->productsAttributesGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation productsAttributesGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttribute[], HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute[]';
        $request = $this->productsAttributesGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttribute[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesGetAsync($context = null)
    {
        return $this->productsAttributesGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute[]';
        $request = $this->productsAttributesGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesGetRequest($context = null)
    {

        $resourcePath = '/products/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttribute
     */
    public function productsAttributesIdDelete($id, $force = null)
    {
        list($response) = $this->productsAttributesIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation productsAttributesIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdDeleteAsync($id, $force = null)
    {
        return $this->productsAttributesIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesIdDelete'
            );
        }

        $resourcePath = '/products/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttribute
     */
    public function productsAttributesIdGet($id, $context = null)
    {
        list($response) = $this->productsAttributesIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation productsAttributesIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdGetAsync($id, $context = null)
    {
        return $this->productsAttributesIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesIdGet'
            );
        }

        $resourcePath = '/products/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesIdPatch
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttribute
     */
    public function productsAttributesIdPatch($body, $id)
    {
        list($response) = $this->productsAttributesIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsAttributesIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdPatchAsync($body, $id)
    {
        return $this->productsAttributesIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsAttributesIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesIdPatch'
            );
        }

        $resourcePath = '/products/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesIdPost
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttribute
     */
    public function productsAttributesIdPost($body, $id)
    {
        list($response) = $this->productsAttributesIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsAttributesIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdPostAsync($body, $id)
    {
        return $this->productsAttributesIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesIdPost'
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsAttributesIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesIdPost'
            );
        }

        $resourcePath = '/products/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesIdPut
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttribute
     */
    public function productsAttributesIdPut($body, $id)
    {
        list($response) = $this->productsAttributesIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsAttributesIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdPutAsync($body, $id)
    {
        return $this->productsAttributesIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesIdPut'
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsAttributesIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsAttributesIdPut'
            );
        }

        $resourcePath = '/products/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAttributesPost
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductAttribute
     */
    public function productsAttributesPost($body)
    {
        list($response) = $this->productsAttributesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation productsAttributesPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAttributesPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAttributesPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesPostAsync($body)
    {
        return $this->productsAttributesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAttributesPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAttributesPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductAttribute';
        $request = $this->productsAttributesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAttributesPost'
     *
     * @param  \WooCommerce\Client\Model\ProductAttribute1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsAttributesPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsAttributesPost'
            );
        }

        $resourcePath = '/products/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsCategoriesGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductCat[]
     */
    public function productsCategoriesGet($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        list($response) = $this->productsCategoriesGetWithHttpInfo($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);
        return $response;
    }

    /**
     * Operation productsCategoriesGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductCat[], HTTP status code, HTTP response headers (array of strings)
     */
    public function productsCategoriesGetWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat[]';
        $request = $this->productsCategoriesGetRequest($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductCat[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsCategoriesGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesGetAsync($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        return $this->productsCategoriesGetAsyncWithHttpInfo($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsCategoriesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat[]';
        $request = $this->productsCategoriesGetRequest($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsCategoriesGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsCategoriesGetRequest($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {

        $resourcePath = '/products/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if ($hide_empty !== null) {
            $queryParams['hide_empty'] = ObjectSerializer::toQueryValue($hide_empty, null);
        }
        // query params
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent, null);
        }
        // query params
        if ($product !== null) {
            $queryParams['product'] = ObjectSerializer::toQueryValue($product, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsCategoriesIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductCat
     */
    public function productsCategoriesIdDelete($id, $force = null)
    {
        list($response) = $this->productsCategoriesIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation productsCategoriesIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductCat, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsCategoriesIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductCat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsCategoriesIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdDeleteAsync($id, $force = null)
    {
        return $this->productsCategoriesIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsCategoriesIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsCategoriesIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsCategoriesIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsCategoriesIdDelete'
            );
        }

        $resourcePath = '/products/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsCategoriesIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductCat
     */
    public function productsCategoriesIdGet($id, $context = null)
    {
        list($response) = $this->productsCategoriesIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation productsCategoriesIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductCat, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsCategoriesIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductCat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsCategoriesIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdGetAsync($id, $context = null)
    {
        return $this->productsCategoriesIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsCategoriesIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsCategoriesIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsCategoriesIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsCategoriesIdGet'
            );
        }

        $resourcePath = '/products/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsCategoriesIdPatch
     *
     * @param  \WooCommerce\Client\Model\ProductCat4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductCat
     */
    public function productsCategoriesIdPatch($body, $id)
    {
        list($response) = $this->productsCategoriesIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsCategoriesIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductCat4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductCat, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsCategoriesIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductCat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsCategoriesIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductCat4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdPatchAsync($body, $id)
    {
        return $this->productsCategoriesIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsCategoriesIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductCat4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsCategoriesIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ProductCat4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsCategoriesIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsCategoriesIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsCategoriesIdPatch'
            );
        }

        $resourcePath = '/products/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsCategoriesIdPost
     *
     * @param  \WooCommerce\Client\Model\ProductCat3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductCat
     */
    public function productsCategoriesIdPost($body, $id)
    {
        list($response) = $this->productsCategoriesIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsCategoriesIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductCat3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductCat, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsCategoriesIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductCat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsCategoriesIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductCat3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdPostAsync($body, $id)
    {
        return $this->productsCategoriesIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsCategoriesIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductCat3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsCategoriesIdPost'
     *
     * @param  \WooCommerce\Client\Model\ProductCat3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsCategoriesIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsCategoriesIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsCategoriesIdPost'
            );
        }

        $resourcePath = '/products/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsCategoriesIdPut
     *
     * @param  \WooCommerce\Client\Model\ProductCat2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductCat
     */
    public function productsCategoriesIdPut($body, $id)
    {
        list($response) = $this->productsCategoriesIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsCategoriesIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductCat2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductCat, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsCategoriesIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductCat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsCategoriesIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductCat2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdPutAsync($body, $id)
    {
        return $this->productsCategoriesIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsCategoriesIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductCat2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsCategoriesIdPut'
     *
     * @param  \WooCommerce\Client\Model\ProductCat2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsCategoriesIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsCategoriesIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsCategoriesIdPut'
            );
        }

        $resourcePath = '/products/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsCategoriesPost
     *
     * @param  \WooCommerce\Client\Model\ProductCat1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductCat
     */
    public function productsCategoriesPost($body)
    {
        list($response) = $this->productsCategoriesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation productsCategoriesPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductCat1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductCat, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsCategoriesPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductCat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsCategoriesPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductCat1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesPostAsync($body)
    {
        return $this->productsCategoriesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsCategoriesPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductCat1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsCategoriesPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductCat';
        $request = $this->productsCategoriesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsCategoriesPost'
     *
     * @param  \WooCommerce\Client\Model\ProductCat1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsCategoriesPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsCategoriesPost'
            );
        }

        $resourcePath = '/products/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $type Limit result set to products assigned a specific type. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $featured Limit result set to featured products. (optional)
     * @param  string $category Limit result set to products assigned a specific category ID. (optional)
     * @param  string $tag Limit result set to products assigned a specific tag ID. (optional)
     * @param  string $shipping_class Limit result set to products assigned a specific shipping class ID. (optional)
     * @param  string $attribute Limit result set to products with a specific attribute. Use the taxonomy name/attribute slug. (optional)
     * @param  string $attribute_term Limit result set to products with a specific attribute term ID (required an assigned attribute). (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Product[]
     */
    public function productsGet($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $type = null, $sku = null, $featured = null, $category = null, $tag = null, $shipping_class = null, $attribute = null, $attribute_term = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {
        list($response) = $this->productsGetWithHttpInfo($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $slug, $status, $type, $sku, $featured, $category, $tag, $shipping_class, $attribute, $attribute_term, $on_sale, $min_price, $max_price, $stock_status);
        return $response;
    }

    /**
     * Operation productsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $type Limit result set to products assigned a specific type. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $featured Limit result set to featured products. (optional)
     * @param  string $category Limit result set to products assigned a specific category ID. (optional)
     * @param  string $tag Limit result set to products assigned a specific tag ID. (optional)
     * @param  string $shipping_class Limit result set to products assigned a specific shipping class ID. (optional)
     * @param  string $attribute Limit result set to products with a specific attribute. Use the taxonomy name/attribute slug. (optional)
     * @param  string $attribute_term Limit result set to products with a specific attribute term ID (required an assigned attribute). (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Product[], HTTP status code, HTTP response headers (array of strings)
     */
    public function productsGetWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $type = null, $sku = null, $featured = null, $category = null, $tag = null, $shipping_class = null, $attribute = null, $attribute_term = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {
        $returnType = '\WooCommerce\Client\Model\Product[]';
        $request = $this->productsGetRequest($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $slug, $status, $type, $sku, $featured, $category, $tag, $shipping_class, $attribute, $attribute_term, $on_sale, $min_price, $max_price, $stock_status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Product[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $type Limit result set to products assigned a specific type. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $featured Limit result set to featured products. (optional)
     * @param  string $category Limit result set to products assigned a specific category ID. (optional)
     * @param  string $tag Limit result set to products assigned a specific tag ID. (optional)
     * @param  string $shipping_class Limit result set to products assigned a specific shipping class ID. (optional)
     * @param  string $attribute Limit result set to products with a specific attribute. Use the taxonomy name/attribute slug. (optional)
     * @param  string $attribute_term Limit result set to products with a specific attribute term ID (required an assigned attribute). (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsGetAsync($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $type = null, $sku = null, $featured = null, $category = null, $tag = null, $shipping_class = null, $attribute = null, $attribute_term = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {
        return $this->productsGetAsyncWithHttpInfo($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $slug, $status, $type, $sku, $featured, $category, $tag, $shipping_class, $attribute, $attribute_term, $on_sale, $min_price, $max_price, $stock_status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $type Limit result set to products assigned a specific type. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $featured Limit result set to featured products. (optional)
     * @param  string $category Limit result set to products assigned a specific category ID. (optional)
     * @param  string $tag Limit result set to products assigned a specific tag ID. (optional)
     * @param  string $shipping_class Limit result set to products assigned a specific shipping class ID. (optional)
     * @param  string $attribute Limit result set to products with a specific attribute. Use the taxonomy name/attribute slug. (optional)
     * @param  string $attribute_term Limit result set to products with a specific attribute term ID (required an assigned attribute). (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $type = null, $sku = null, $featured = null, $category = null, $tag = null, $shipping_class = null, $attribute = null, $attribute_term = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {
        $returnType = '\WooCommerce\Client\Model\Product[]';
        $request = $this->productsGetRequest($context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $slug, $status, $type, $sku, $featured, $category, $tag, $shipping_class, $attribute, $attribute_term, $on_sale, $min_price, $max_price, $stock_status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $type Limit result set to products assigned a specific type. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $featured Limit result set to featured products. (optional)
     * @param  string $category Limit result set to products assigned a specific category ID. (optional)
     * @param  string $tag Limit result set to products assigned a specific tag ID. (optional)
     * @param  string $shipping_class Limit result set to products assigned a specific shipping class ID. (optional)
     * @param  string $attribute Limit result set to products with a specific attribute. Use the taxonomy name/attribute slug. (optional)
     * @param  string $attribute_term Limit result set to products with a specific attribute term ID (required an assigned attribute). (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsGetRequest($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $type = null, $sku = null, $featured = null, $category = null, $tag = null, $shipping_class = null, $attribute = null, $attribute_term = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {

        $resourcePath = '/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if ($after !== null) {
            $queryParams['after'] = ObjectSerializer::toQueryValue($after, 'string');
        }
        // query params
        if ($before !== null) {
            $queryParams['before'] = ObjectSerializer::toQueryValue($before, 'string');
        }
        // query params
        if ($modified_after !== null) {
            $queryParams['modified_after'] = ObjectSerializer::toQueryValue($modified_after, 'string');
        }
        // query params
        if ($modified_before !== null) {
            $queryParams['modified_before'] = ObjectSerializer::toQueryValue($modified_before, 'string');
        }
        // query params
        if ($dates_are_gmt !== null) {
            $queryParams['dates_are_gmt'] = ObjectSerializer::toQueryValue($dates_are_gmt, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if (is_array($parent)) {
            $parent = ObjectSerializer::serializeCollection($parent, 'multi', true);
        }
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent, null);
        }
        // query params
        if (is_array($parent_exclude)) {
            $parent_exclude = ObjectSerializer::serializeCollection($parent_exclude, 'multi', true);
        }
        if ($parent_exclude !== null) {
            $queryParams['parent_exclude'] = ObjectSerializer::toQueryValue($parent_exclude, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($featured !== null) {
            $queryParams['featured'] = ObjectSerializer::toQueryValue($featured, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag, null);
        }
        // query params
        if ($shipping_class !== null) {
            $queryParams['shipping_class'] = ObjectSerializer::toQueryValue($shipping_class, null);
        }
        // query params
        if ($attribute !== null) {
            $queryParams['attribute'] = ObjectSerializer::toQueryValue($attribute, null);
        }
        // query params
        if ($attribute_term !== null) {
            $queryParams['attribute_term'] = ObjectSerializer::toQueryValue($attribute_term, null);
        }
        // query params
        if ($on_sale !== null) {
            $queryParams['on_sale'] = ObjectSerializer::toQueryValue($on_sale, null);
        }
        // query params
        if ($min_price !== null) {
            $queryParams['min_price'] = ObjectSerializer::toQueryValue($min_price, null);
        }
        // query params
        if ($max_price !== null) {
            $queryParams['max_price'] = ObjectSerializer::toQueryValue($max_price, null);
        }
        // query params
        if ($stock_status !== null) {
            $queryParams['stock_status'] = ObjectSerializer::toQueryValue($stock_status, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Product
     */
    public function productsIdDelete($id, $force = null)
    {
        list($response) = $this->productsIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation productsIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdDeleteAsync($id, $force = null)
    {
        return $this->productsIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsIdDelete'
            );
        }

        $resourcePath = '/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Product
     */
    public function productsIdGet($id, $context = null)
    {
        list($response) = $this->productsIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation productsIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdGetAsync($id, $context = null)
    {
        return $this->productsIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsIdGet'
            );
        }

        $resourcePath = '/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsIdPatch
     *
     * @param  \WooCommerce\Client\Model\Product4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Product
     */
    public function productsIdPatch($body, $id)
    {
        list($response) = $this->productsIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Product4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Product4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdPatchAsync($body, $id)
    {
        return $this->productsIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Product4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsIdPatch'
     *
     * @param  \WooCommerce\Client\Model\Product4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsIdPatch'
            );
        }

        $resourcePath = '/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsIdPost
     *
     * @param  \WooCommerce\Client\Model\Product3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Product
     */
    public function productsIdPost($body, $id)
    {
        list($response) = $this->productsIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Product3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Product3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdPostAsync($body, $id)
    {
        return $this->productsIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Product3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsIdPost'
     *
     * @param  \WooCommerce\Client\Model\Product3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsIdPost'
            );
        }

        $resourcePath = '/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsIdPut
     *
     * @param  \WooCommerce\Client\Model\Product2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Product
     */
    public function productsIdPut($body, $id)
    {
        list($response) = $this->productsIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Product2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Product2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdPutAsync($body, $id)
    {
        return $this->productsIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Product2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsIdPut'
     *
     * @param  \WooCommerce\Client\Model\Product2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsIdPut'
            );
        }

        $resourcePath = '/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsPost
     *
     * @param  \WooCommerce\Client\Model\Product1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Product
     */
    public function productsPost($body)
    {
        list($response) = $this->productsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation productsPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Product1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Product1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsPostAsync($body)
    {
        return $this->productsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Product1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\Product';
        $request = $this->productsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsPost'
     *
     * @param  \WooCommerce\Client\Model\Product1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsPost'
            );
        }

        $resourcePath = '/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsProductIdVariationsGet
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductVariation[]
     */
    public function productsProductIdVariationsGet($product_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $sku = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {
        list($response) = $this->productsProductIdVariationsGetWithHttpInfo($product_id, $context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $slug, $status, $sku, $on_sale, $min_price, $max_price, $stock_status);
        return $response;
    }

    /**
     * Operation productsProductIdVariationsGetWithHttpInfo
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductVariation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function productsProductIdVariationsGetWithHttpInfo($product_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $sku = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation[]';
        $request = $this->productsProductIdVariationsGetRequest($product_id, $context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $slug, $status, $sku, $on_sale, $min_price, $max_price, $stock_status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductVariation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsProductIdVariationsGetAsync
     *
     * 
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsGetAsync($product_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $sku = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {
        return $this->productsProductIdVariationsGetAsyncWithHttpInfo($product_id, $context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $slug, $status, $sku, $on_sale, $min_price, $max_price, $stock_status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsProductIdVariationsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsGetAsyncWithHttpInfo($product_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $sku = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation[]';
        $request = $this->productsProductIdVariationsGetRequest($product_id, $context, $page, $per_page, $search, $after, $before, $modified_after, $modified_before, $dates_are_gmt, $exclude, $include, $offset, $order, $orderby, $parent, $parent_exclude, $slug, $status, $sku, $on_sale, $min_price, $max_price, $stock_status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsProductIdVariationsGet'
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  string $modified_after Limit response to resources modified after a given ISO8601 compliant date. (optional)
     * @param  string $modified_before Limit response to resources modified before a given ISO8601 compliant date. (optional)
     * @param  bool $dates_are_gmt Whether to consider GMT post dates when limiting response by published or modified date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $parent Limit result set to those of particular parent IDs. (optional)
     * @param  int[] $parent_exclude Limit result set to all items except those of a particular parent ID. (optional)
     * @param  string $slug Limit result set to products with a specific slug. (optional)
     * @param  string $status Limit result set to products assigned a specific status. (optional)
     * @param  string $sku Limit result set to products with specific SKU(s). Use commas to separate. (optional)
     * @param  bool $on_sale Limit result set to products on sale. (optional)
     * @param  string $min_price Limit result set to products based on a minimum price. (optional)
     * @param  string $max_price Limit result set to products based on a maximum price. (optional)
     * @param  string $stock_status Limit result set to products with specified stock status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsProductIdVariationsGetRequest($product_id, $context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $modified_after = null, $modified_before = null, $dates_are_gmt = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $parent = null, $parent_exclude = null, $slug = null, $status = null, $sku = null, $on_sale = null, $min_price = null, $max_price = null, $stock_status = null)
    {
        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productsProductIdVariationsGet'
            );
        }

        $resourcePath = '/products/{product_id}/variations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if ($after !== null) {
            $queryParams['after'] = ObjectSerializer::toQueryValue($after, 'string');
        }
        // query params
        if ($before !== null) {
            $queryParams['before'] = ObjectSerializer::toQueryValue($before, 'string');
        }
        // query params
        if ($modified_after !== null) {
            $queryParams['modified_after'] = ObjectSerializer::toQueryValue($modified_after, 'string');
        }
        // query params
        if ($modified_before !== null) {
            $queryParams['modified_before'] = ObjectSerializer::toQueryValue($modified_before, 'string');
        }
        // query params
        if ($dates_are_gmt !== null) {
            $queryParams['dates_are_gmt'] = ObjectSerializer::toQueryValue($dates_are_gmt, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if (is_array($parent)) {
            $parent = ObjectSerializer::serializeCollection($parent, 'multi', true);
        }
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent, null);
        }
        // query params
        if (is_array($parent_exclude)) {
            $parent_exclude = ObjectSerializer::serializeCollection($parent_exclude, 'multi', true);
        }
        if ($parent_exclude !== null) {
            $queryParams['parent_exclude'] = ObjectSerializer::toQueryValue($parent_exclude, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }
        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($on_sale !== null) {
            $queryParams['on_sale'] = ObjectSerializer::toQueryValue($on_sale, null);
        }
        // query params
        if ($min_price !== null) {
            $queryParams['min_price'] = ObjectSerializer::toQueryValue($min_price, null);
        }
        // query params
        if ($max_price !== null) {
            $queryParams['max_price'] = ObjectSerializer::toQueryValue($max_price, null);
        }
        // query params
        if ($stock_status !== null) {
            $queryParams['stock_status'] = ObjectSerializer::toQueryValue($stock_status, null);
        }

        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsProductIdVariationsIdDelete
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductVariation
     */
    public function productsProductIdVariationsIdDelete($product_id, $id, $force = null)
    {
        list($response) = $this->productsProductIdVariationsIdDeleteWithHttpInfo($product_id, $id, $force);
        return $response;
    }

    /**
     * Operation productsProductIdVariationsIdDeleteWithHttpInfo
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductVariation, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsProductIdVariationsIdDeleteWithHttpInfo($product_id, $id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdDeleteRequest($product_id, $id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductVariation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsProductIdVariationsIdDeleteAsync
     *
     * 
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdDeleteAsync($product_id, $id, $force = null)
    {
        return $this->productsProductIdVariationsIdDeleteAsyncWithHttpInfo($product_id, $id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsProductIdVariationsIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdDeleteAsyncWithHttpInfo($product_id, $id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdDeleteRequest($product_id, $id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsProductIdVariationsIdDelete'
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsProductIdVariationsIdDeleteRequest($product_id, $id, $force = null)
    {
        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productsProductIdVariationsIdDelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsProductIdVariationsIdDelete'
            );
        }

        $resourcePath = '/products/{product_id}/variations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsProductIdVariationsIdGet
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductVariation
     */
    public function productsProductIdVariationsIdGet($product_id, $id, $context = null)
    {
        list($response) = $this->productsProductIdVariationsIdGetWithHttpInfo($product_id, $id, $context);
        return $response;
    }

    /**
     * Operation productsProductIdVariationsIdGetWithHttpInfo
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductVariation, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsProductIdVariationsIdGetWithHttpInfo($product_id, $id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdGetRequest($product_id, $id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductVariation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsProductIdVariationsIdGetAsync
     *
     * 
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdGetAsync($product_id, $id, $context = null)
    {
        return $this->productsProductIdVariationsIdGetAsyncWithHttpInfo($product_id, $id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsProductIdVariationsIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdGetAsyncWithHttpInfo($product_id, $id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdGetRequest($product_id, $id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsProductIdVariationsIdGet'
     *
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsProductIdVariationsIdGetRequest($product_id, $id, $context = null)
    {
        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productsProductIdVariationsIdGet'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsProductIdVariationsIdGet'
            );
        }

        $resourcePath = '/products/{product_id}/variations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsProductIdVariationsIdPatch
     *
     * @param  \WooCommerce\Client\Model\ProductVariation4 $body body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductVariation
     */
    public function productsProductIdVariationsIdPatch($body, $product_id, $id)
    {
        list($response) = $this->productsProductIdVariationsIdPatchWithHttpInfo($body, $product_id, $id);
        return $response;
    }

    /**
     * Operation productsProductIdVariationsIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductVariation4 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductVariation, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsProductIdVariationsIdPatchWithHttpInfo($body, $product_id, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdPatchRequest($body, $product_id, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductVariation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsProductIdVariationsIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductVariation4 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdPatchAsync($body, $product_id, $id)
    {
        return $this->productsProductIdVariationsIdPatchAsyncWithHttpInfo($body, $product_id, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsProductIdVariationsIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductVariation4 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdPatchAsyncWithHttpInfo($body, $product_id, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdPatchRequest($body, $product_id, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsProductIdVariationsIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ProductVariation4 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsProductIdVariationsIdPatchRequest($body, $product_id, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsProductIdVariationsIdPatch'
            );
        }
        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productsProductIdVariationsIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsProductIdVariationsIdPatch'
            );
        }

        $resourcePath = '/products/{product_id}/variations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsProductIdVariationsIdPost
     *
     * @param  \WooCommerce\Client\Model\ProductVariation3 $body body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductVariation
     */
    public function productsProductIdVariationsIdPost($body, $product_id, $id)
    {
        list($response) = $this->productsProductIdVariationsIdPostWithHttpInfo($body, $product_id, $id);
        return $response;
    }

    /**
     * Operation productsProductIdVariationsIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductVariation3 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductVariation, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsProductIdVariationsIdPostWithHttpInfo($body, $product_id, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdPostRequest($body, $product_id, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductVariation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsProductIdVariationsIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductVariation3 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdPostAsync($body, $product_id, $id)
    {
        return $this->productsProductIdVariationsIdPostAsyncWithHttpInfo($body, $product_id, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsProductIdVariationsIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductVariation3 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdPostAsyncWithHttpInfo($body, $product_id, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdPostRequest($body, $product_id, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsProductIdVariationsIdPost'
     *
     * @param  \WooCommerce\Client\Model\ProductVariation3 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsProductIdVariationsIdPostRequest($body, $product_id, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsProductIdVariationsIdPost'
            );
        }
        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productsProductIdVariationsIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsProductIdVariationsIdPost'
            );
        }

        $resourcePath = '/products/{product_id}/variations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsProductIdVariationsIdPut
     *
     * @param  \WooCommerce\Client\Model\ProductVariation2 $body body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductVariation
     */
    public function productsProductIdVariationsIdPut($body, $product_id, $id)
    {
        list($response) = $this->productsProductIdVariationsIdPutWithHttpInfo($body, $product_id, $id);
        return $response;
    }

    /**
     * Operation productsProductIdVariationsIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductVariation2 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductVariation, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsProductIdVariationsIdPutWithHttpInfo($body, $product_id, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdPutRequest($body, $product_id, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductVariation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsProductIdVariationsIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductVariation2 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdPutAsync($body, $product_id, $id)
    {
        return $this->productsProductIdVariationsIdPutAsyncWithHttpInfo($body, $product_id, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsProductIdVariationsIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductVariation2 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsIdPutAsyncWithHttpInfo($body, $product_id, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsIdPutRequest($body, $product_id, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsProductIdVariationsIdPut'
     *
     * @param  \WooCommerce\Client\Model\ProductVariation2 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     * @param  int $id Unique identifier for the variation. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsProductIdVariationsIdPutRequest($body, $product_id, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsProductIdVariationsIdPut'
            );
        }
        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productsProductIdVariationsIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsProductIdVariationsIdPut'
            );
        }

        $resourcePath = '/products/{product_id}/variations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsProductIdVariationsPost
     *
     * @param  \WooCommerce\Client\Model\ProductVariation1 $body body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductVariation
     */
    public function productsProductIdVariationsPost($body, $product_id)
    {
        list($response) = $this->productsProductIdVariationsPostWithHttpInfo($body, $product_id);
        return $response;
    }

    /**
     * Operation productsProductIdVariationsPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductVariation1 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductVariation, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsProductIdVariationsPostWithHttpInfo($body, $product_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsPostRequest($body, $product_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductVariation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsProductIdVariationsPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductVariation1 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsPostAsync($body, $product_id)
    {
        return $this->productsProductIdVariationsPostAsyncWithHttpInfo($body, $product_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsProductIdVariationsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductVariation1 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsProductIdVariationsPostAsyncWithHttpInfo($body, $product_id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductVariation';
        $request = $this->productsProductIdVariationsPostRequest($body, $product_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsProductIdVariationsPost'
     *
     * @param  \WooCommerce\Client\Model\ProductVariation1 $body (required)
     * @param  int $product_id Unique identifier for the variable product. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsProductIdVariationsPostRequest($body, $product_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsProductIdVariationsPost'
            );
        }
        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productsProductIdVariationsPost'
            );
        }

        $resourcePath = '/products/{product_id}/variations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsReviewsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to reviews published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $reviewer Limit result set to reviews assigned to specific user IDs. (optional)
     * @param  int[] $reviewer_exclude Ensure result set excludes reviews assigned to specific user IDs. (optional)
     * @param  string $reviewer_email Limit result set to that from a specific author email. (optional)
     * @param  int[] $product Limit result set to reviews assigned to specific product IDs. (optional)
     * @param  string $status Limit result set to reviews assigned a specific status. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductReview[]
     */
    public function productsReviewsGet($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $reviewer = null, $reviewer_exclude = null, $reviewer_email = null, $product = null, $status = null)
    {
        list($response) = $this->productsReviewsGetWithHttpInfo($context, $page, $per_page, $search, $after, $before, $exclude, $include, $offset, $order, $orderby, $reviewer, $reviewer_exclude, $reviewer_email, $product, $status);
        return $response;
    }

    /**
     * Operation productsReviewsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to reviews published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $reviewer Limit result set to reviews assigned to specific user IDs. (optional)
     * @param  int[] $reviewer_exclude Ensure result set excludes reviews assigned to specific user IDs. (optional)
     * @param  string $reviewer_email Limit result set to that from a specific author email. (optional)
     * @param  int[] $product Limit result set to reviews assigned to specific product IDs. (optional)
     * @param  string $status Limit result set to reviews assigned a specific status. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductReview[], HTTP status code, HTTP response headers (array of strings)
     */
    public function productsReviewsGetWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $reviewer = null, $reviewer_exclude = null, $reviewer_email = null, $product = null, $status = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview[]';
        $request = $this->productsReviewsGetRequest($context, $page, $per_page, $search, $after, $before, $exclude, $include, $offset, $order, $orderby, $reviewer, $reviewer_exclude, $reviewer_email, $product, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductReview[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsReviewsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to reviews published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $reviewer Limit result set to reviews assigned to specific user IDs. (optional)
     * @param  int[] $reviewer_exclude Ensure result set excludes reviews assigned to specific user IDs. (optional)
     * @param  string $reviewer_email Limit result set to that from a specific author email. (optional)
     * @param  int[] $product Limit result set to reviews assigned to specific product IDs. (optional)
     * @param  string $status Limit result set to reviews assigned a specific status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsGetAsync($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $reviewer = null, $reviewer_exclude = null, $reviewer_email = null, $product = null, $status = null)
    {
        return $this->productsReviewsGetAsyncWithHttpInfo($context, $page, $per_page, $search, $after, $before, $exclude, $include, $offset, $order, $orderby, $reviewer, $reviewer_exclude, $reviewer_email, $product, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsReviewsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to reviews published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $reviewer Limit result set to reviews assigned to specific user IDs. (optional)
     * @param  int[] $reviewer_exclude Ensure result set excludes reviews assigned to specific user IDs. (optional)
     * @param  string $reviewer_email Limit result set to that from a specific author email. (optional)
     * @param  int[] $product Limit result set to reviews assigned to specific product IDs. (optional)
     * @param  string $status Limit result set to reviews assigned a specific status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $reviewer = null, $reviewer_exclude = null, $reviewer_email = null, $product = null, $status = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview[]';
        $request = $this->productsReviewsGetRequest($context, $page, $per_page, $search, $after, $before, $exclude, $include, $offset, $order, $orderby, $reviewer, $reviewer_exclude, $reviewer_email, $product, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsReviewsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to reviews published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific IDs. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  int[] $reviewer Limit result set to reviews assigned to specific user IDs. (optional)
     * @param  int[] $reviewer_exclude Ensure result set excludes reviews assigned to specific user IDs. (optional)
     * @param  string $reviewer_email Limit result set to that from a specific author email. (optional)
     * @param  int[] $product Limit result set to reviews assigned to specific product IDs. (optional)
     * @param  string $status Limit result set to reviews assigned a specific status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsReviewsGetRequest($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $reviewer = null, $reviewer_exclude = null, $reviewer_email = null, $product = null, $status = null)
    {

        $resourcePath = '/products/reviews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if ($after !== null) {
            $queryParams['after'] = ObjectSerializer::toQueryValue($after, 'string');
        }
        // query params
        if ($before !== null) {
            $queryParams['before'] = ObjectSerializer::toQueryValue($before, 'string');
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if (is_array($reviewer)) {
            $reviewer = ObjectSerializer::serializeCollection($reviewer, 'multi', true);
        }
        if ($reviewer !== null) {
            $queryParams['reviewer'] = ObjectSerializer::toQueryValue($reviewer, null);
        }
        // query params
        if (is_array($reviewer_exclude)) {
            $reviewer_exclude = ObjectSerializer::serializeCollection($reviewer_exclude, 'multi', true);
        }
        if ($reviewer_exclude !== null) {
            $queryParams['reviewer_exclude'] = ObjectSerializer::toQueryValue($reviewer_exclude, null);
        }
        // query params
        if ($reviewer_email !== null) {
            $queryParams['reviewer_email'] = ObjectSerializer::toQueryValue($reviewer_email, 'email');
        }
        // query params
        if (is_array($product)) {
            $product = ObjectSerializer::serializeCollection($product, 'multi', true);
        }
        if ($product !== null) {
            $queryParams['product'] = ObjectSerializer::toQueryValue($product, null);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsReviewsIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductReview
     */
    public function productsReviewsIdDelete($id, $force = null)
    {
        list($response) = $this->productsReviewsIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation productsReviewsIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductReview, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsReviewsIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductReview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsReviewsIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdDeleteAsync($id, $force = null)
    {
        return $this->productsReviewsIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsReviewsIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsReviewsIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsReviewsIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsReviewsIdDelete'
            );
        }

        $resourcePath = '/products/reviews/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsReviewsIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductReview
     */
    public function productsReviewsIdGet($id, $context = null)
    {
        list($response) = $this->productsReviewsIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation productsReviewsIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductReview, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsReviewsIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductReview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsReviewsIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdGetAsync($id, $context = null)
    {
        return $this->productsReviewsIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsReviewsIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsReviewsIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsReviewsIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsReviewsIdGet'
            );
        }

        $resourcePath = '/products/reviews/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsReviewsIdPatch
     *
     * @param  \WooCommerce\Client\Model\ProductReview4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductReview
     */
    public function productsReviewsIdPatch($body, $id)
    {
        list($response) = $this->productsReviewsIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsReviewsIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductReview4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductReview, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsReviewsIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductReview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsReviewsIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductReview4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdPatchAsync($body, $id)
    {
        return $this->productsReviewsIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsReviewsIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductReview4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsReviewsIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ProductReview4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsReviewsIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsReviewsIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsReviewsIdPatch'
            );
        }

        $resourcePath = '/products/reviews/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsReviewsIdPost
     *
     * @param  \WooCommerce\Client\Model\ProductReview3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductReview
     */
    public function productsReviewsIdPost($body, $id)
    {
        list($response) = $this->productsReviewsIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsReviewsIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductReview3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductReview, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsReviewsIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductReview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsReviewsIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductReview3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdPostAsync($body, $id)
    {
        return $this->productsReviewsIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsReviewsIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductReview3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsReviewsIdPost'
     *
     * @param  \WooCommerce\Client\Model\ProductReview3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsReviewsIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsReviewsIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsReviewsIdPost'
            );
        }

        $resourcePath = '/products/reviews/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsReviewsIdPut
     *
     * @param  \WooCommerce\Client\Model\ProductReview2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductReview
     */
    public function productsReviewsIdPut($body, $id)
    {
        list($response) = $this->productsReviewsIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsReviewsIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductReview2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductReview, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsReviewsIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductReview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsReviewsIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductReview2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdPutAsync($body, $id)
    {
        return $this->productsReviewsIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsReviewsIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductReview2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsReviewsIdPut'
     *
     * @param  \WooCommerce\Client\Model\ProductReview2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsReviewsIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsReviewsIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsReviewsIdPut'
            );
        }

        $resourcePath = '/products/reviews/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsReviewsPost
     *
     * @param  \WooCommerce\Client\Model\ProductReview1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductReview
     */
    public function productsReviewsPost($body)
    {
        list($response) = $this->productsReviewsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation productsReviewsPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductReview1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductReview, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsReviewsPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductReview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsReviewsPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductReview1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsPostAsync($body)
    {
        return $this->productsReviewsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsReviewsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductReview1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsReviewsPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductReview';
        $request = $this->productsReviewsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsReviewsPost'
     *
     * @param  \WooCommerce\Client\Model\ProductReview1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsReviewsPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsReviewsPost'
            );
        }

        $resourcePath = '/products/reviews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsShippingClassesGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductShippingClass[]
     */
    public function productsShippingClassesGet($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        list($response) = $this->productsShippingClassesGetWithHttpInfo($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);
        return $response;
    }

    /**
     * Operation productsShippingClassesGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductShippingClass[], HTTP status code, HTTP response headers (array of strings)
     */
    public function productsShippingClassesGetWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass[]';
        $request = $this->productsShippingClassesGetRequest($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductShippingClass[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsShippingClassesGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesGetAsync($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        return $this->productsShippingClassesGetAsyncWithHttpInfo($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsShippingClassesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass[]';
        $request = $this->productsShippingClassesGetRequest($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsShippingClassesGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsShippingClassesGetRequest($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {

        $resourcePath = '/products/shipping_classes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if ($hide_empty !== null) {
            $queryParams['hide_empty'] = ObjectSerializer::toQueryValue($hide_empty, null);
        }
        // query params
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent, null);
        }
        // query params
        if ($product !== null) {
            $queryParams['product'] = ObjectSerializer::toQueryValue($product, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsShippingClassesIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductShippingClass
     */
    public function productsShippingClassesIdDelete($id, $force = null)
    {
        list($response) = $this->productsShippingClassesIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation productsShippingClassesIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductShippingClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsShippingClassesIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductShippingClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsShippingClassesIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdDeleteAsync($id, $force = null)
    {
        return $this->productsShippingClassesIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsShippingClassesIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsShippingClassesIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsShippingClassesIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsShippingClassesIdDelete'
            );
        }

        $resourcePath = '/products/shipping_classes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsShippingClassesIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductShippingClass
     */
    public function productsShippingClassesIdGet($id, $context = null)
    {
        list($response) = $this->productsShippingClassesIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation productsShippingClassesIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductShippingClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsShippingClassesIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductShippingClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsShippingClassesIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdGetAsync($id, $context = null)
    {
        return $this->productsShippingClassesIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsShippingClassesIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsShippingClassesIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsShippingClassesIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsShippingClassesIdGet'
            );
        }

        $resourcePath = '/products/shipping_classes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsShippingClassesIdPatch
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductShippingClass
     */
    public function productsShippingClassesIdPatch($body, $id)
    {
        list($response) = $this->productsShippingClassesIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsShippingClassesIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductShippingClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsShippingClassesIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductShippingClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsShippingClassesIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdPatchAsync($body, $id)
    {
        return $this->productsShippingClassesIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsShippingClassesIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsShippingClassesIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsShippingClassesIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsShippingClassesIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsShippingClassesIdPatch'
            );
        }

        $resourcePath = '/products/shipping_classes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsShippingClassesIdPost
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductShippingClass
     */
    public function productsShippingClassesIdPost($body, $id)
    {
        list($response) = $this->productsShippingClassesIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsShippingClassesIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductShippingClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsShippingClassesIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductShippingClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsShippingClassesIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdPostAsync($body, $id)
    {
        return $this->productsShippingClassesIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsShippingClassesIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsShippingClassesIdPost'
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsShippingClassesIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsShippingClassesIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsShippingClassesIdPost'
            );
        }

        $resourcePath = '/products/shipping_classes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsShippingClassesIdPut
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductShippingClass
     */
    public function productsShippingClassesIdPut($body, $id)
    {
        list($response) = $this->productsShippingClassesIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsShippingClassesIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductShippingClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsShippingClassesIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductShippingClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsShippingClassesIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdPutAsync($body, $id)
    {
        return $this->productsShippingClassesIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsShippingClassesIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsShippingClassesIdPut'
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsShippingClassesIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsShippingClassesIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsShippingClassesIdPut'
            );
        }

        $resourcePath = '/products/shipping_classes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsShippingClassesPost
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductShippingClass
     */
    public function productsShippingClassesPost($body)
    {
        list($response) = $this->productsShippingClassesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation productsShippingClassesPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductShippingClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsShippingClassesPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductShippingClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsShippingClassesPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesPostAsync($body)
    {
        return $this->productsShippingClassesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsShippingClassesPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsShippingClassesPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductShippingClass';
        $request = $this->productsShippingClassesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsShippingClassesPost'
     *
     * @param  \WooCommerce\Client\Model\ProductShippingClass1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsShippingClassesPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsShippingClassesPost'
            );
        }

        $resourcePath = '/products/shipping_classes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsTagsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductTag[]
     */
    public function productsTagsGet($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        list($response) = $this->productsTagsGetWithHttpInfo($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);
        return $response;
    }

    /**
     * Operation productsTagsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductTag[], HTTP status code, HTTP response headers (array of strings)
     */
    public function productsTagsGetWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag[]';
        $request = $this->productsTagsGetRequest($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductTag[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsTagsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsGetAsync($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        return $this->productsTagsGetAsyncWithHttpInfo($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsTagsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag[]';
        $request = $this->productsTagsGetRequest($context, $page, $per_page, $search, $exclude, $include, $offset, $order, $orderby, $hide_empty, $parent, $product, $slug);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsTagsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. Applies to hierarchical taxonomies only. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by resource attribute. (optional)
     * @param  bool $hide_empty Whether to hide resources not assigned to any products. (optional)
     * @param  int $parent Limit result set to resources assigned to a specific parent. Applies to hierarchical taxonomies only. (optional)
     * @param  int $product Limit result set to resources assigned to a specific product. (optional)
     * @param  string $slug Limit result set to resources with a specific slug. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsTagsGetRequest($context = null, $page = null, $per_page = null, $search = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $hide_empty = null, $parent = null, $product = null, $slug = null)
    {

        $resourcePath = '/products/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if ($hide_empty !== null) {
            $queryParams['hide_empty'] = ObjectSerializer::toQueryValue($hide_empty, null);
        }
        // query params
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent, null);
        }
        // query params
        if ($product !== null) {
            $queryParams['product'] = ObjectSerializer::toQueryValue($product, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsTagsIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductTag
     */
    public function productsTagsIdDelete($id, $force = null)
    {
        list($response) = $this->productsTagsIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation productsTagsIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsTagsIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsTagsIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdDeleteAsync($id, $force = null)
    {
        return $this->productsTagsIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsTagsIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsTagsIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsTagsIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsTagsIdDelete'
            );
        }

        $resourcePath = '/products/tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsTagsIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductTag
     */
    public function productsTagsIdGet($id, $context = null)
    {
        list($response) = $this->productsTagsIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation productsTagsIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsTagsIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsTagsIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdGetAsync($id, $context = null)
    {
        return $this->productsTagsIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsTagsIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsTagsIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsTagsIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsTagsIdGet'
            );
        }

        $resourcePath = '/products/tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsTagsIdPatch
     *
     * @param  \WooCommerce\Client\Model\ProductTag4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductTag
     */
    public function productsTagsIdPatch($body, $id)
    {
        list($response) = $this->productsTagsIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsTagsIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductTag4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsTagsIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsTagsIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductTag4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdPatchAsync($body, $id)
    {
        return $this->productsTagsIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsTagsIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductTag4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsTagsIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ProductTag4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsTagsIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsTagsIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsTagsIdPatch'
            );
        }

        $resourcePath = '/products/tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsTagsIdPost
     *
     * @param  \WooCommerce\Client\Model\ProductTag3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductTag
     */
    public function productsTagsIdPost($body, $id)
    {
        list($response) = $this->productsTagsIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsTagsIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductTag3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsTagsIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsTagsIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductTag3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdPostAsync($body, $id)
    {
        return $this->productsTagsIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsTagsIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductTag3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsTagsIdPost'
     *
     * @param  \WooCommerce\Client\Model\ProductTag3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsTagsIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsTagsIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsTagsIdPost'
            );
        }

        $resourcePath = '/products/tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsTagsIdPut
     *
     * @param  \WooCommerce\Client\Model\ProductTag2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductTag
     */
    public function productsTagsIdPut($body, $id)
    {
        list($response) = $this->productsTagsIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation productsTagsIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductTag2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsTagsIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsTagsIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductTag2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdPutAsync($body, $id)
    {
        return $this->productsTagsIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsTagsIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductTag2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsTagsIdPut'
     *
     * @param  \WooCommerce\Client\Model\ProductTag2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsTagsIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsTagsIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsTagsIdPut'
            );
        }

        $resourcePath = '/products/tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsTagsPost
     *
     * @param  \WooCommerce\Client\Model\ProductTag1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ProductTag
     */
    public function productsTagsPost($body)
    {
        list($response) = $this->productsTagsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation productsTagsPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ProductTag1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ProductTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsTagsPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ProductTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsTagsPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductTag1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsPostAsync($body)
    {
        return $this->productsTagsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsTagsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ProductTag1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsTagsPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ProductTag';
        $request = $this->productsTagsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsTagsPost'
     *
     * @param  \WooCommerce\Client\Model\ProductTag1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsTagsPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling productsTagsPost'
            );
        }

        $resourcePath = '/products/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsCouponsTotalsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ReportCouponTotal[]
     */
    public function reportsCouponsTotalsGet($context = null)
    {
        list($response) = $this->reportsCouponsTotalsGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation reportsCouponsTotalsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ReportCouponTotal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsCouponsTotalsGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportCouponTotal[]';
        $request = $this->reportsCouponsTotalsGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ReportCouponTotal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsCouponsTotalsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCouponsTotalsGetAsync($context = null)
    {
        return $this->reportsCouponsTotalsGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsCouponsTotalsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCouponsTotalsGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportCouponTotal[]';
        $request = $this->reportsCouponsTotalsGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsCouponsTotalsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportsCouponsTotalsGetRequest($context = null)
    {

        $resourcePath = '/reports/coupons/totals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsCustomersTotalsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ReportCustomerTotal[]
     */
    public function reportsCustomersTotalsGet($context = null)
    {
        list($response) = $this->reportsCustomersTotalsGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation reportsCustomersTotalsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ReportCustomerTotal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsCustomersTotalsGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportCustomerTotal[]';
        $request = $this->reportsCustomersTotalsGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ReportCustomerTotal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsCustomersTotalsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCustomersTotalsGetAsync($context = null)
    {
        return $this->reportsCustomersTotalsGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsCustomersTotalsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCustomersTotalsGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportCustomerTotal[]';
        $request = $this->reportsCustomersTotalsGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsCustomersTotalsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportsCustomersTotalsGetRequest($context = null)
    {

        $resourcePath = '/reports/customers/totals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Report[]
     */
    public function reportsGet($context = null)
    {
        list($response) = $this->reportsGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation reportsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Report[], HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Report[]';
        $request = $this->reportsGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Report[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsGetAsync($context = null)
    {
        return $this->reportsGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Report[]';
        $request = $this->reportsGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportsGetRequest($context = null)
    {

        $resourcePath = '/reports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsOrdersTotalsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ReportOrderTotal[]
     */
    public function reportsOrdersTotalsGet($context = null)
    {
        list($response) = $this->reportsOrdersTotalsGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation reportsOrdersTotalsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ReportOrderTotal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsOrdersTotalsGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportOrderTotal[]';
        $request = $this->reportsOrdersTotalsGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ReportOrderTotal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsOrdersTotalsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsOrdersTotalsGetAsync($context = null)
    {
        return $this->reportsOrdersTotalsGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsOrdersTotalsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsOrdersTotalsGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportOrderTotal[]';
        $request = $this->reportsOrdersTotalsGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsOrdersTotalsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportsOrdersTotalsGetRequest($context = null)
    {

        $resourcePath = '/reports/orders/totals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsProductsTotalsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ReportProductTotal[]
     */
    public function reportsProductsTotalsGet($context = null)
    {
        list($response) = $this->reportsProductsTotalsGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation reportsProductsTotalsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ReportProductTotal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsProductsTotalsGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportProductTotal[]';
        $request = $this->reportsProductsTotalsGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ReportProductTotal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsProductsTotalsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsProductsTotalsGetAsync($context = null)
    {
        return $this->reportsProductsTotalsGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsProductsTotalsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsProductsTotalsGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportProductTotal[]';
        $request = $this->reportsProductsTotalsGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsProductsTotalsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportsProductsTotalsGetRequest($context = null)
    {

        $resourcePath = '/reports/products/totals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsReviewsTotalsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ReportReviewTotal[]
     */
    public function reportsReviewsTotalsGet($context = null)
    {
        list($response) = $this->reportsReviewsTotalsGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation reportsReviewsTotalsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ReportReviewTotal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsReviewsTotalsGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportReviewTotal[]';
        $request = $this->reportsReviewsTotalsGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ReportReviewTotal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsReviewsTotalsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsReviewsTotalsGetAsync($context = null)
    {
        return $this->reportsReviewsTotalsGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsReviewsTotalsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsReviewsTotalsGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ReportReviewTotal[]';
        $request = $this->reportsReviewsTotalsGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsReviewsTotalsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportsReviewsTotalsGetRequest($context = null)
    {

        $resourcePath = '/reports/reviews/totals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsSalesGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\SalesReport[]
     */
    public function reportsSalesGet($context = null, $period = null, $date_min = null, $date_max = null)
    {
        list($response) = $this->reportsSalesGetWithHttpInfo($context, $period, $date_min, $date_max);
        return $response;
    }

    /**
     * Operation reportsSalesGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\SalesReport[], HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsSalesGetWithHttpInfo($context = null, $period = null, $date_min = null, $date_max = null)
    {
        $returnType = '\WooCommerce\Client\Model\SalesReport[]';
        $request = $this->reportsSalesGetRequest($context, $period, $date_min, $date_max);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\SalesReport[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsSalesGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsSalesGetAsync($context = null, $period = null, $date_min = null, $date_max = null)
    {
        return $this->reportsSalesGetAsyncWithHttpInfo($context, $period, $date_min, $date_max)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsSalesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsSalesGetAsyncWithHttpInfo($context = null, $period = null, $date_min = null, $date_max = null)
    {
        $returnType = '\WooCommerce\Client\Model\SalesReport[]';
        $request = $this->reportsSalesGetRequest($context, $period, $date_min, $date_max);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsSalesGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportsSalesGetRequest($context = null, $period = null, $date_min = null, $date_max = null)
    {

        $resourcePath = '/reports/sales';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($period !== null) {
            $queryParams['period'] = ObjectSerializer::toQueryValue($period, null);
        }
        // query params
        if ($date_min !== null) {
            $queryParams['date_min'] = ObjectSerializer::toQueryValue($date_min, 'date');
        }
        // query params
        if ($date_max !== null) {
            $queryParams['date_max'] = ObjectSerializer::toQueryValue($date_max, 'date');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsTopSellersGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\TopSellersReport[]
     */
    public function reportsTopSellersGet($context = null, $period = null, $date_min = null, $date_max = null)
    {
        list($response) = $this->reportsTopSellersGetWithHttpInfo($context, $period, $date_min, $date_max);
        return $response;
    }

    /**
     * Operation reportsTopSellersGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\TopSellersReport[], HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsTopSellersGetWithHttpInfo($context = null, $period = null, $date_min = null, $date_max = null)
    {
        $returnType = '\WooCommerce\Client\Model\TopSellersReport[]';
        $request = $this->reportsTopSellersGetRequest($context, $period, $date_min, $date_max);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\TopSellersReport[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsTopSellersGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsTopSellersGetAsync($context = null, $period = null, $date_min = null, $date_max = null)
    {
        return $this->reportsTopSellersGetAsyncWithHttpInfo($context, $period, $date_min, $date_max)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsTopSellersGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsTopSellersGetAsyncWithHttpInfo($context = null, $period = null, $date_min = null, $date_max = null)
    {
        $returnType = '\WooCommerce\Client\Model\TopSellersReport[]';
        $request = $this->reportsTopSellersGetRequest($context, $period, $date_min, $date_max);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsTopSellersGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  string $period Report period. (optional)
     * @param  \DateTime $date_min Return sales for a specific start date, the date need to be in the YYYY-MM-DD format. (optional)
     * @param  \DateTime $date_max Return sales for a specific end date, the date need to be in the YYYY-MM-DD format. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportsTopSellersGetRequest($context = null, $period = null, $date_min = null, $date_max = null)
    {

        $resourcePath = '/reports/top_sellers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($period !== null) {
            $queryParams['period'] = ObjectSerializer::toQueryValue($period, null);
        }
        // query params
        if ($date_min !== null) {
            $queryParams['date_min'] = ObjectSerializer::toQueryValue($date_min, 'date');
        }
        // query params
        if ($date_max !== null) {
            $queryParams['date_max'] = ObjectSerializer::toQueryValue($date_max, 'date');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rootGet
     *
     * @param  string $namespace namespace (optional)
     * @param  string $context context (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function rootGet($namespace = null, $context = null)
    {
        $this->rootGetWithHttpInfo($namespace, $context);
    }

    /**
     * Operation rootGetWithHttpInfo
     *
     * @param  string $namespace (optional)
     * @param  string $context (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rootGetWithHttpInfo($namespace = null, $context = null)
    {
        $returnType = '';
        $request = $this->rootGetRequest($namespace, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rootGetAsync
     *
     * 
     *
     * @param  string $namespace (optional)
     * @param  string $context (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rootGetAsync($namespace = null, $context = null)
    {
        return $this->rootGetAsyncWithHttpInfo($namespace, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rootGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace (optional)
     * @param  string $context (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rootGetAsyncWithHttpInfo($namespace = null, $context = null)
    {
        $returnType = '';
        $request = $this->rootGetRequest($namespace, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rootGet'
     *
     * @param  string $namespace (optional)
     * @param  string $context (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rootGetRequest($namespace = null, $context = null)
    {

        $resourcePath = '/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($namespace !== null) {
            $queryParams['namespace'] = ObjectSerializer::toQueryValue($namespace, null);
        }
        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingMethodsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingMethod[]
     */
    public function shippingMethodsGet($context = null)
    {
        list($response) = $this->shippingMethodsGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation shippingMethodsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingMethod[], HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingMethodsGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingMethod[]';
        $request = $this->shippingMethodsGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingMethod[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingMethodsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingMethodsGetAsync($context = null)
    {
        return $this->shippingMethodsGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingMethodsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingMethodsGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingMethod[]';
        $request = $this->shippingMethodsGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingMethodsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingMethodsGetRequest($context = null)
    {

        $resourcePath = '/shipping_methods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingMethodsIdGet
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingMethod
     */
    public function shippingMethodsIdGet($id, $context = null)
    {
        list($response) = $this->shippingMethodsIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation shippingMethodsIdGetWithHttpInfo
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingMethod, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingMethodsIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingMethod';
        $request = $this->shippingMethodsIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingMethod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingMethodsIdGetAsync
     *
     * 
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingMethodsIdGetAsync($id, $context = null)
    {
        return $this->shippingMethodsIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingMethodsIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingMethodsIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingMethod';
        $request = $this->shippingMethodsIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingMethodsIdGet'
     *
     * @param  string $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingMethodsIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingMethodsIdGet'
            );
        }

        $resourcePath = '/shipping_methods/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesGet
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZone[]
     */
    public function shippingZonesGet()
    {
        list($response) = $this->shippingZonesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation shippingZonesGetWithHttpInfo
     *
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesGetWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone[]';
        $request = $this->shippingZonesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesGetAsync()
    {
        return $this->shippingZonesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesGetAsyncWithHttpInfo()
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone[]';
        $request = $this->shippingZonesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesGetRequest()
    {

        $resourcePath = '/shipping/zones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesIdDelete
     *
     * @param  int $id Unique ID for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZone
     */
    public function shippingZonesIdDelete($id, $force = null)
    {
        list($response) = $this->shippingZonesIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation shippingZonesIdDeleteWithHttpInfo
     *
     * @param  int $id Unique ID for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZone, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique ID for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdDeleteAsync($id, $force = null)
    {
        return $this->shippingZonesIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique ID for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesIdDelete'
     *
     * @param  int $id Unique ID for the resource. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingZonesIdDelete'
            );
        }

        $resourcePath = '/shipping/zones/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesIdGet
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZone
     */
    public function shippingZonesIdGet($id)
    {
        list($response) = $this->shippingZonesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation shippingZonesIdGetWithHttpInfo
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZone, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesIdGetWithHttpInfo($id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesIdGetAsync
     *
     * 
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdGetAsync($id)
    {
        return $this->shippingZonesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesIdGet'
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingZonesIdGet'
            );
        }

        $resourcePath = '/shipping/zones/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesIdLocationsGet
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneLocation[]
     */
    public function shippingZonesIdLocationsGet($id)
    {
        list($response) = $this->shippingZonesIdLocationsGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation shippingZonesIdLocationsGetWithHttpInfo
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneLocation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesIdLocationsGetWithHttpInfo($id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneLocation[]';
        $request = $this->shippingZonesIdLocationsGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneLocation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesIdLocationsGetAsync
     *
     * 
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdLocationsGetAsync($id)
    {
        return $this->shippingZonesIdLocationsGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesIdLocationsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdLocationsGetAsyncWithHttpInfo($id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneLocation[]';
        $request = $this->shippingZonesIdLocationsGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesIdLocationsGet'
     *
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesIdLocationsGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingZonesIdLocationsGet'
            );
        }

        $resourcePath = '/shipping/zones/{id}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesIdLocationsPatch
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation3 $body body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneLocation
     */
    public function shippingZonesIdLocationsPatch($body, $id)
    {
        list($response) = $this->shippingZonesIdLocationsPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation shippingZonesIdLocationsPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation3 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesIdLocationsPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneLocation';
        $request = $this->shippingZonesIdLocationsPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesIdLocationsPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation3 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdLocationsPatchAsync($body, $id)
    {
        return $this->shippingZonesIdLocationsPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesIdLocationsPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation3 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdLocationsPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneLocation';
        $request = $this->shippingZonesIdLocationsPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesIdLocationsPatch'
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation3 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesIdLocationsPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesIdLocationsPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingZonesIdLocationsPatch'
            );
        }

        $resourcePath = '/shipping/zones/{id}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesIdLocationsPost
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation2 $body body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneLocation
     */
    public function shippingZonesIdLocationsPost($body, $id)
    {
        list($response) = $this->shippingZonesIdLocationsPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation shippingZonesIdLocationsPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation2 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesIdLocationsPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneLocation';
        $request = $this->shippingZonesIdLocationsPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesIdLocationsPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation2 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdLocationsPostAsync($body, $id)
    {
        return $this->shippingZonesIdLocationsPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesIdLocationsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation2 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdLocationsPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneLocation';
        $request = $this->shippingZonesIdLocationsPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesIdLocationsPost'
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation2 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesIdLocationsPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesIdLocationsPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingZonesIdLocationsPost'
            );
        }

        $resourcePath = '/shipping/zones/{id}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesIdLocationsPut
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation1 $body body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneLocation
     */
    public function shippingZonesIdLocationsPut($body, $id)
    {
        list($response) = $this->shippingZonesIdLocationsPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation shippingZonesIdLocationsPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation1 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesIdLocationsPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneLocation';
        $request = $this->shippingZonesIdLocationsPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesIdLocationsPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation1 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdLocationsPutAsync($body, $id)
    {
        return $this->shippingZonesIdLocationsPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesIdLocationsPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation1 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdLocationsPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneLocation';
        $request = $this->shippingZonesIdLocationsPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesIdLocationsPut'
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneLocation1 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesIdLocationsPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesIdLocationsPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingZonesIdLocationsPut'
            );
        }

        $resourcePath = '/shipping/zones/{id}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesIdPatch
     *
     * @param  \WooCommerce\Client\Model\ShippingZone4 $body body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZone
     */
    public function shippingZonesIdPatch($body, $id)
    {
        list($response) = $this->shippingZonesIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation shippingZonesIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZone4 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZone, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZone4 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdPatchAsync($body, $id)
    {
        return $this->shippingZonesIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZone4 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ShippingZone4 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingZonesIdPatch'
            );
        }

        $resourcePath = '/shipping/zones/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesIdPost
     *
     * @param  \WooCommerce\Client\Model\ShippingZone3 $body body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZone
     */
    public function shippingZonesIdPost($body, $id)
    {
        list($response) = $this->shippingZonesIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation shippingZonesIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZone3 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZone, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZone3 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdPostAsync($body, $id)
    {
        return $this->shippingZonesIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZone3 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesIdPost'
     *
     * @param  \WooCommerce\Client\Model\ShippingZone3 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingZonesIdPost'
            );
        }

        $resourcePath = '/shipping/zones/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesIdPut
     *
     * @param  \WooCommerce\Client\Model\ShippingZone2 $body body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZone
     */
    public function shippingZonesIdPut($body, $id)
    {
        list($response) = $this->shippingZonesIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation shippingZonesIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZone2 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZone, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZone2 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdPutAsync($body, $id)
    {
        return $this->shippingZonesIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZone2 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesIdPut'
     *
     * @param  \WooCommerce\Client\Model\ShippingZone2 $body (required)
     * @param  int $id Unique ID for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling shippingZonesIdPut'
            );
        }

        $resourcePath = '/shipping/zones/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesPost
     *
     * @param  \WooCommerce\Client\Model\ShippingZone1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZone
     */
    public function shippingZonesPost($body)
    {
        list($response) = $this->shippingZonesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation shippingZonesPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZone1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZone, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZone1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesPostAsync($body)
    {
        return $this->shippingZonesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZone1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZone';
        $request = $this->shippingZonesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesPost'
     *
     * @param  \WooCommerce\Client\Model\ShippingZone1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesPost'
            );
        }

        $resourcePath = '/shipping/zones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesZoneIdMethodsGet
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneMethod[]
     */
    public function shippingZonesZoneIdMethodsGet($zone_id)
    {
        list($response) = $this->shippingZonesZoneIdMethodsGetWithHttpInfo($zone_id);
        return $response;
    }

    /**
     * Operation shippingZonesZoneIdMethodsGetWithHttpInfo
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneMethod[], HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesZoneIdMethodsGetWithHttpInfo($zone_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod[]';
        $request = $this->shippingZonesZoneIdMethodsGetRequest($zone_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneMethod[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesZoneIdMethodsGetAsync
     *
     * 
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsGetAsync($zone_id)
    {
        return $this->shippingZonesZoneIdMethodsGetAsyncWithHttpInfo($zone_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesZoneIdMethodsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsGetAsyncWithHttpInfo($zone_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod[]';
        $request = $this->shippingZonesZoneIdMethodsGetRequest($zone_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesZoneIdMethodsGet'
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesZoneIdMethodsGetRequest($zone_id)
    {
        // verify the required parameter 'zone_id' is set
        if ($zone_id === null || (is_array($zone_id) && count($zone_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_id when calling shippingZonesZoneIdMethodsGet'
            );
        }

        $resourcePath = '/shipping/zones/{zone_id}/methods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($zone_id !== null) {
            $resourcePath = str_replace(
                '{' . 'zone_id' . '}',
                ObjectSerializer::toPathValue($zone_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdDelete
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneMethod
     */
    public function shippingZonesZoneIdMethodsInstanceIdDelete($zone_id, $instance_id, $force = null)
    {
        list($response) = $this->shippingZonesZoneIdMethodsInstanceIdDeleteWithHttpInfo($zone_id, $instance_id, $force);
        return $response;
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdDeleteWithHttpInfo
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneMethod, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesZoneIdMethodsInstanceIdDeleteWithHttpInfo($zone_id, $instance_id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdDeleteRequest($zone_id, $instance_id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneMethod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdDeleteAsync
     *
     * 
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdDeleteAsync($zone_id, $instance_id, $force = null)
    {
        return $this->shippingZonesZoneIdMethodsInstanceIdDeleteAsyncWithHttpInfo($zone_id, $instance_id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdDeleteAsyncWithHttpInfo($zone_id, $instance_id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdDeleteRequest($zone_id, $instance_id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesZoneIdMethodsInstanceIdDelete'
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     * @param  bool $force Whether to bypass trash and force deletion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesZoneIdMethodsInstanceIdDeleteRequest($zone_id, $instance_id, $force = null)
    {
        // verify the required parameter 'zone_id' is set
        if ($zone_id === null || (is_array($zone_id) && count($zone_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_id when calling shippingZonesZoneIdMethodsInstanceIdDelete'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling shippingZonesZoneIdMethodsInstanceIdDelete'
            );
        }

        $resourcePath = '/shipping/zones/{zone_id}/methods/{instance_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($zone_id !== null) {
            $resourcePath = str_replace(
                '{' . 'zone_id' . '}',
                ObjectSerializer::toPathValue($zone_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instance_id' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdGet
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneMethod
     */
    public function shippingZonesZoneIdMethodsInstanceIdGet($zone_id, $instance_id)
    {
        list($response) = $this->shippingZonesZoneIdMethodsInstanceIdGetWithHttpInfo($zone_id, $instance_id);
        return $response;
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdGetWithHttpInfo
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneMethod, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesZoneIdMethodsInstanceIdGetWithHttpInfo($zone_id, $instance_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdGetRequest($zone_id, $instance_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneMethod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdGetAsync
     *
     * 
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdGetAsync($zone_id, $instance_id)
    {
        return $this->shippingZonesZoneIdMethodsInstanceIdGetAsyncWithHttpInfo($zone_id, $instance_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdGetAsyncWithHttpInfo($zone_id, $instance_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdGetRequest($zone_id, $instance_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesZoneIdMethodsInstanceIdGet'
     *
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesZoneIdMethodsInstanceIdGetRequest($zone_id, $instance_id)
    {
        // verify the required parameter 'zone_id' is set
        if ($zone_id === null || (is_array($zone_id) && count($zone_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_id when calling shippingZonesZoneIdMethodsInstanceIdGet'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling shippingZonesZoneIdMethodsInstanceIdGet'
            );
        }

        $resourcePath = '/shipping/zones/{zone_id}/methods/{instance_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($zone_id !== null) {
            $resourcePath = str_replace(
                '{' . 'zone_id' . '}',
                ObjectSerializer::toPathValue($zone_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instance_id' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPatch
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod4 $body body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneMethod
     */
    public function shippingZonesZoneIdMethodsInstanceIdPatch($body, $zone_id, $instance_id)
    {
        list($response) = $this->shippingZonesZoneIdMethodsInstanceIdPatchWithHttpInfo($body, $zone_id, $instance_id);
        return $response;
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod4 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneMethod, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesZoneIdMethodsInstanceIdPatchWithHttpInfo($body, $zone_id, $instance_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdPatchRequest($body, $zone_id, $instance_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneMethod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod4 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdPatchAsync($body, $zone_id, $instance_id)
    {
        return $this->shippingZonesZoneIdMethodsInstanceIdPatchAsyncWithHttpInfo($body, $zone_id, $instance_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod4 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdPatchAsyncWithHttpInfo($body, $zone_id, $instance_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdPatchRequest($body, $zone_id, $instance_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesZoneIdMethodsInstanceIdPatch'
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod4 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesZoneIdMethodsInstanceIdPatchRequest($body, $zone_id, $instance_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesZoneIdMethodsInstanceIdPatch'
            );
        }
        // verify the required parameter 'zone_id' is set
        if ($zone_id === null || (is_array($zone_id) && count($zone_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_id when calling shippingZonesZoneIdMethodsInstanceIdPatch'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling shippingZonesZoneIdMethodsInstanceIdPatch'
            );
        }

        $resourcePath = '/shipping/zones/{zone_id}/methods/{instance_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($zone_id !== null) {
            $resourcePath = str_replace(
                '{' . 'zone_id' . '}',
                ObjectSerializer::toPathValue($zone_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instance_id' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPost
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod3 $body body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneMethod
     */
    public function shippingZonesZoneIdMethodsInstanceIdPost($body, $zone_id, $instance_id)
    {
        list($response) = $this->shippingZonesZoneIdMethodsInstanceIdPostWithHttpInfo($body, $zone_id, $instance_id);
        return $response;
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod3 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneMethod, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesZoneIdMethodsInstanceIdPostWithHttpInfo($body, $zone_id, $instance_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdPostRequest($body, $zone_id, $instance_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneMethod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod3 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdPostAsync($body, $zone_id, $instance_id)
    {
        return $this->shippingZonesZoneIdMethodsInstanceIdPostAsyncWithHttpInfo($body, $zone_id, $instance_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod3 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdPostAsyncWithHttpInfo($body, $zone_id, $instance_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdPostRequest($body, $zone_id, $instance_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesZoneIdMethodsInstanceIdPost'
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod3 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesZoneIdMethodsInstanceIdPostRequest($body, $zone_id, $instance_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesZoneIdMethodsInstanceIdPost'
            );
        }
        // verify the required parameter 'zone_id' is set
        if ($zone_id === null || (is_array($zone_id) && count($zone_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_id when calling shippingZonesZoneIdMethodsInstanceIdPost'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling shippingZonesZoneIdMethodsInstanceIdPost'
            );
        }

        $resourcePath = '/shipping/zones/{zone_id}/methods/{instance_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($zone_id !== null) {
            $resourcePath = str_replace(
                '{' . 'zone_id' . '}',
                ObjectSerializer::toPathValue($zone_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instance_id' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPut
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod2 $body body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneMethod
     */
    public function shippingZonesZoneIdMethodsInstanceIdPut($body, $zone_id, $instance_id)
    {
        list($response) = $this->shippingZonesZoneIdMethodsInstanceIdPutWithHttpInfo($body, $zone_id, $instance_id);
        return $response;
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod2 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneMethod, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesZoneIdMethodsInstanceIdPutWithHttpInfo($body, $zone_id, $instance_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdPutRequest($body, $zone_id, $instance_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneMethod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod2 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdPutAsync($body, $zone_id, $instance_id)
    {
        return $this->shippingZonesZoneIdMethodsInstanceIdPutAsyncWithHttpInfo($body, $zone_id, $instance_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesZoneIdMethodsInstanceIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod2 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsInstanceIdPutAsyncWithHttpInfo($body, $zone_id, $instance_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsInstanceIdPutRequest($body, $zone_id, $instance_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesZoneIdMethodsInstanceIdPut'
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod2 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     * @param  int $instance_id Unique ID for the instance. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesZoneIdMethodsInstanceIdPutRequest($body, $zone_id, $instance_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesZoneIdMethodsInstanceIdPut'
            );
        }
        // verify the required parameter 'zone_id' is set
        if ($zone_id === null || (is_array($zone_id) && count($zone_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_id when calling shippingZonesZoneIdMethodsInstanceIdPut'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling shippingZonesZoneIdMethodsInstanceIdPut'
            );
        }

        $resourcePath = '/shipping/zones/{zone_id}/methods/{instance_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($zone_id !== null) {
            $resourcePath = str_replace(
                '{' . 'zone_id' . '}',
                ObjectSerializer::toPathValue($zone_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instance_id' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingZonesZoneIdMethodsPost
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod1 $body body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\ShippingZoneMethod
     */
    public function shippingZonesZoneIdMethodsPost($body, $zone_id)
    {
        list($response) = $this->shippingZonesZoneIdMethodsPostWithHttpInfo($body, $zone_id);
        return $response;
    }

    /**
     * Operation shippingZonesZoneIdMethodsPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod1 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\ShippingZoneMethod, HTTP status code, HTTP response headers (array of strings)
     */
    public function shippingZonesZoneIdMethodsPostWithHttpInfo($body, $zone_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsPostRequest($body, $zone_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\ShippingZoneMethod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shippingZonesZoneIdMethodsPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod1 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsPostAsync($body, $zone_id)
    {
        return $this->shippingZonesZoneIdMethodsPostAsyncWithHttpInfo($body, $zone_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingZonesZoneIdMethodsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod1 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingZonesZoneIdMethodsPostAsyncWithHttpInfo($body, $zone_id)
    {
        $returnType = '\WooCommerce\Client\Model\ShippingZoneMethod';
        $request = $this->shippingZonesZoneIdMethodsPostRequest($body, $zone_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingZonesZoneIdMethodsPost'
     *
     * @param  \WooCommerce\Client\Model\ShippingZoneMethod1 $body (required)
     * @param  int $zone_id Unique ID for the zone. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingZonesZoneIdMethodsPostRequest($body, $zone_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shippingZonesZoneIdMethodsPost'
            );
        }
        // verify the required parameter 'zone_id' is set
        if ($zone_id === null || (is_array($zone_id) && count($zone_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_id when calling shippingZonesZoneIdMethodsPost'
            );
        }

        $resourcePath = '/shipping/zones/{zone_id}/methods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($zone_id !== null) {
            $resourcePath = str_replace(
                '{' . 'zone_id' . '}',
                ObjectSerializer::toPathValue($zone_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation systemStatusGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\SystemStatus
     */
    public function systemStatusGet($context = null)
    {
        list($response) = $this->systemStatusGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation systemStatusGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\SystemStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function systemStatusGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatus';
        $request = $this->systemStatusGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\SystemStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation systemStatusGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusGetAsync($context = null)
    {
        return $this->systemStatusGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation systemStatusGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatus';
        $request = $this->systemStatusGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'systemStatusGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function systemStatusGetRequest($context = null)
    {

        $resourcePath = '/system_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation systemStatusToolsGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\SystemStatusTool[]
     */
    public function systemStatusToolsGet($context = null)
    {
        list($response) = $this->systemStatusToolsGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation systemStatusToolsGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\SystemStatusTool[], HTTP status code, HTTP response headers (array of strings)
     */
    public function systemStatusToolsGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool[]';
        $request = $this->systemStatusToolsGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\SystemStatusTool[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation systemStatusToolsGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsGetAsync($context = null)
    {
        return $this->systemStatusToolsGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation systemStatusToolsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool[]';
        $request = $this->systemStatusToolsGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'systemStatusToolsGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function systemStatusToolsGetRequest($context = null)
    {

        $resourcePath = '/system_status/tools';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation systemStatusToolsIdGet
     *
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\SystemStatusTool
     */
    public function systemStatusToolsIdGet($id)
    {
        list($response) = $this->systemStatusToolsIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation systemStatusToolsIdGetWithHttpInfo
     *
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\SystemStatusTool, HTTP status code, HTTP response headers (array of strings)
     */
    public function systemStatusToolsIdGetWithHttpInfo($id)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool';
        $request = $this->systemStatusToolsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\SystemStatusTool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation systemStatusToolsIdGetAsync
     *
     * 
     *
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsIdGetAsync($id)
    {
        return $this->systemStatusToolsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation systemStatusToolsIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool';
        $request = $this->systemStatusToolsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'systemStatusToolsIdGet'
     *
     * @param  string $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function systemStatusToolsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling systemStatusToolsIdGet'
            );
        }

        $resourcePath = '/system_status/tools/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation systemStatusToolsIdPatch
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool3 $body body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\SystemStatusTool
     */
    public function systemStatusToolsIdPatch($body, $id)
    {
        list($response) = $this->systemStatusToolsIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation systemStatusToolsIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool3 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\SystemStatusTool, HTTP status code, HTTP response headers (array of strings)
     */
    public function systemStatusToolsIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool';
        $request = $this->systemStatusToolsIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\SystemStatusTool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation systemStatusToolsIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool3 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsIdPatchAsync($body, $id)
    {
        return $this->systemStatusToolsIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation systemStatusToolsIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool3 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool';
        $request = $this->systemStatusToolsIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'systemStatusToolsIdPatch'
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool3 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function systemStatusToolsIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling systemStatusToolsIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling systemStatusToolsIdPatch'
            );
        }

        $resourcePath = '/system_status/tools/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation systemStatusToolsIdPost
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool2 $body body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\SystemStatusTool
     */
    public function systemStatusToolsIdPost($body, $id)
    {
        list($response) = $this->systemStatusToolsIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation systemStatusToolsIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool2 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\SystemStatusTool, HTTP status code, HTTP response headers (array of strings)
     */
    public function systemStatusToolsIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool';
        $request = $this->systemStatusToolsIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\SystemStatusTool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation systemStatusToolsIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool2 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsIdPostAsync($body, $id)
    {
        return $this->systemStatusToolsIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation systemStatusToolsIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool2 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool';
        $request = $this->systemStatusToolsIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'systemStatusToolsIdPost'
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool2 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function systemStatusToolsIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling systemStatusToolsIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling systemStatusToolsIdPost'
            );
        }

        $resourcePath = '/system_status/tools/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation systemStatusToolsIdPut
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool1 $body body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\SystemStatusTool
     */
    public function systemStatusToolsIdPut($body, $id)
    {
        list($response) = $this->systemStatusToolsIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation systemStatusToolsIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool1 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\SystemStatusTool, HTTP status code, HTTP response headers (array of strings)
     */
    public function systemStatusToolsIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool';
        $request = $this->systemStatusToolsIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\SystemStatusTool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation systemStatusToolsIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool1 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsIdPutAsync($body, $id)
    {
        return $this->systemStatusToolsIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation systemStatusToolsIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool1 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemStatusToolsIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\SystemStatusTool';
        $request = $this->systemStatusToolsIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'systemStatusToolsIdPut'
     *
     * @param  \WooCommerce\Client\Model\SystemStatusTool1 $body (required)
     * @param  string $id A unique identifier for the tool. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function systemStatusToolsIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling systemStatusToolsIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling systemStatusToolsIdPut'
            );
        }

        $resourcePath = '/system_status/tools/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesClassesGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\TaxClass[]
     */
    public function taxesClassesGet($context = null)
    {
        list($response) = $this->taxesClassesGetWithHttpInfo($context);
        return $response;
    }

    /**
     * Operation taxesClassesGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\TaxClass[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesClassesGetWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\TaxClass[]';
        $request = $this->taxesClassesGetRequest($context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\TaxClass[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesClassesGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesClassesGetAsync($context = null)
    {
        return $this->taxesClassesGetAsyncWithHttpInfo($context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesClassesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesClassesGetAsyncWithHttpInfo($context = null)
    {
        $returnType = '\WooCommerce\Client\Model\TaxClass[]';
        $request = $this->taxesClassesGetRequest($context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesClassesGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesClassesGetRequest($context = null)
    {

        $resourcePath = '/taxes/classes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesClassesPost
     *
     * @param  \WooCommerce\Client\Model\TaxClass1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\TaxClass
     */
    public function taxesClassesPost($body)
    {
        list($response) = $this->taxesClassesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation taxesClassesPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\TaxClass1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\TaxClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesClassesPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\TaxClass';
        $request = $this->taxesClassesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\TaxClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesClassesPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\TaxClass1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesClassesPostAsync($body)
    {
        return $this->taxesClassesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesClassesPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\TaxClass1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesClassesPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\TaxClass';
        $request = $this->taxesClassesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesClassesPost'
     *
     * @param  \WooCommerce\Client\Model\TaxClass1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesClassesPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taxesClassesPost'
            );
        }

        $resourcePath = '/taxes/classes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesClassesSlugDelete
     *
     * @param  string $slug Unique slug for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\TaxClass
     */
    public function taxesClassesSlugDelete($slug, $force = null)
    {
        list($response) = $this->taxesClassesSlugDeleteWithHttpInfo($slug, $force);
        return $response;
    }

    /**
     * Operation taxesClassesSlugDeleteWithHttpInfo
     *
     * @param  string $slug Unique slug for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\TaxClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesClassesSlugDeleteWithHttpInfo($slug, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\TaxClass';
        $request = $this->taxesClassesSlugDeleteRequest($slug, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\TaxClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesClassesSlugDeleteAsync
     *
     * 
     *
     * @param  string $slug Unique slug for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesClassesSlugDeleteAsync($slug, $force = null)
    {
        return $this->taxesClassesSlugDeleteAsyncWithHttpInfo($slug, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesClassesSlugDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $slug Unique slug for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesClassesSlugDeleteAsyncWithHttpInfo($slug, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\TaxClass';
        $request = $this->taxesClassesSlugDeleteRequest($slug, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesClassesSlugDelete'
     *
     * @param  string $slug Unique slug for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesClassesSlugDeleteRequest($slug, $force = null)
    {
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling taxesClassesSlugDelete'
            );
        }

        $resourcePath = '/taxes/classes/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesClassesSlugGet
     *
     * @param  string $slug Unique slug for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\TaxClass
     */
    public function taxesClassesSlugGet($slug)
    {
        list($response) = $this->taxesClassesSlugGetWithHttpInfo($slug);
        return $response;
    }

    /**
     * Operation taxesClassesSlugGetWithHttpInfo
     *
     * @param  string $slug Unique slug for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\TaxClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesClassesSlugGetWithHttpInfo($slug)
    {
        $returnType = '\WooCommerce\Client\Model\TaxClass';
        $request = $this->taxesClassesSlugGetRequest($slug);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\TaxClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesClassesSlugGetAsync
     *
     * 
     *
     * @param  string $slug Unique slug for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesClassesSlugGetAsync($slug)
    {
        return $this->taxesClassesSlugGetAsyncWithHttpInfo($slug)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesClassesSlugGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $slug Unique slug for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesClassesSlugGetAsyncWithHttpInfo($slug)
    {
        $returnType = '\WooCommerce\Client\Model\TaxClass';
        $request = $this->taxesClassesSlugGetRequest($slug);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesClassesSlugGet'
     *
     * @param  string $slug Unique slug for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesClassesSlugGetRequest($slug)
    {
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling taxesClassesSlugGet'
            );
        }

        $resourcePath = '/taxes/classes/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $class Sort by tax class. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Tax[]
     */
    public function taxesGet($context = null, $page = null, $per_page = null, $offset = null, $order = null, $orderby = null, $class = null)
    {
        list($response) = $this->taxesGetWithHttpInfo($context, $page, $per_page, $offset, $order, $orderby, $class);
        return $response;
    }

    /**
     * Operation taxesGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $class Sort by tax class. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Tax[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesGetWithHttpInfo($context = null, $page = null, $per_page = null, $offset = null, $order = null, $orderby = null, $class = null)
    {
        $returnType = '\WooCommerce\Client\Model\Tax[]';
        $request = $this->taxesGetRequest($context, $page, $per_page, $offset, $order, $orderby, $class);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Tax[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $class Sort by tax class. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesGetAsync($context = null, $page = null, $per_page = null, $offset = null, $order = null, $orderby = null, $class = null)
    {
        return $this->taxesGetAsyncWithHttpInfo($context, $page, $per_page, $offset, $order, $orderby, $class)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $class Sort by tax class. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $offset = null, $order = null, $orderby = null, $class = null)
    {
        $returnType = '\WooCommerce\Client\Model\Tax[]';
        $request = $this->taxesGetRequest($context, $page, $per_page, $offset, $order, $orderby, $class);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $class Sort by tax class. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesGetRequest($context = null, $page = null, $per_page = null, $offset = null, $order = null, $orderby = null, $class = null)
    {

        $resourcePath = '/taxes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if ($class !== null) {
            $queryParams['class'] = ObjectSerializer::toQueryValue($class, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Tax
     */
    public function taxesIdDelete($id, $force = null)
    {
        list($response) = $this->taxesIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation taxesIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Tax, HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Tax',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdDeleteAsync($id, $force = null)
    {
        return $this->taxesIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling taxesIdDelete'
            );
        }

        $resourcePath = '/taxes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Tax
     */
    public function taxesIdGet($id, $context = null)
    {
        list($response) = $this->taxesIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation taxesIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Tax, HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Tax',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdGetAsync($id, $context = null)
    {
        return $this->taxesIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling taxesIdGet'
            );
        }

        $resourcePath = '/taxes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesIdPatch
     *
     * @param  \WooCommerce\Client\Model\Tax4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Tax
     */
    public function taxesIdPatch($body, $id)
    {
        list($response) = $this->taxesIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation taxesIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Tax4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Tax, HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Tax',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Tax4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdPatchAsync($body, $id)
    {
        return $this->taxesIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Tax4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesIdPatch'
     *
     * @param  \WooCommerce\Client\Model\Tax4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taxesIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling taxesIdPatch'
            );
        }

        $resourcePath = '/taxes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesIdPost
     *
     * @param  \WooCommerce\Client\Model\Tax3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Tax
     */
    public function taxesIdPost($body, $id)
    {
        list($response) = $this->taxesIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation taxesIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Tax3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Tax, HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Tax',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Tax3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdPostAsync($body, $id)
    {
        return $this->taxesIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Tax3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesIdPost'
     *
     * @param  \WooCommerce\Client\Model\Tax3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taxesIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling taxesIdPost'
            );
        }

        $resourcePath = '/taxes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesIdPut
     *
     * @param  \WooCommerce\Client\Model\Tax2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Tax
     */
    public function taxesIdPut($body, $id)
    {
        list($response) = $this->taxesIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation taxesIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Tax2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Tax, HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Tax',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Tax2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdPutAsync($body, $id)
    {
        return $this->taxesIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Tax2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesIdPut'
     *
     * @param  \WooCommerce\Client\Model\Tax2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taxesIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling taxesIdPut'
            );
        }

        $resourcePath = '/taxes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taxesPost
     *
     * @param  \WooCommerce\Client\Model\Tax1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Tax
     */
    public function taxesPost($body)
    {
        list($response) = $this->taxesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation taxesPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Tax1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Tax, HTTP status code, HTTP response headers (array of strings)
     */
    public function taxesPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Tax',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taxesPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Tax1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesPostAsync($body)
    {
        return $this->taxesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taxesPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Tax1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taxesPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\Tax';
        $request = $this->taxesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taxesPost'
     *
     * @param  \WooCommerce\Client\Model\Tax1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taxesPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taxesPost'
            );
        }

        $resourcePath = '/taxes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webhooksGet
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $status Limit result set to webhooks assigned a specific status. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Webhook[]
     */
    public function webhooksGet($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $status = null)
    {
        list($response) = $this->webhooksGetWithHttpInfo($context, $page, $per_page, $search, $after, $before, $exclude, $include, $offset, $order, $orderby, $status);
        return $response;
    }

    /**
     * Operation webhooksGetWithHttpInfo
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $status Limit result set to webhooks assigned a specific status. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Webhook[], HTTP status code, HTTP response headers (array of strings)
     */
    public function webhooksGetWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $status = null)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook[]';
        $request = $this->webhooksGetRequest($context, $page, $per_page, $search, $after, $before, $exclude, $include, $offset, $order, $orderby, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Webhook[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webhooksGetAsync
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $status Limit result set to webhooks assigned a specific status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksGetAsync($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $status = null)
    {
        return $this->webhooksGetAsyncWithHttpInfo($context, $page, $per_page, $search, $after, $before, $exclude, $include, $offset, $order, $orderby, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webhooksGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $status Limit result set to webhooks assigned a specific status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksGetAsyncWithHttpInfo($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $status = null)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook[]';
        $request = $this->webhooksGetRequest($context, $page, $per_page, $search, $after, $before, $exclude, $include, $offset, $order, $orderby, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webhooksGet'
     *
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     * @param  int $page Current page of the collection. (optional)
     * @param  int $per_page Maximum number of items to be returned in result set. (optional)
     * @param  string $search Limit results to those matching a string. (optional)
     * @param  string $after Limit response to resources published after a given ISO8601 compliant date. (optional)
     * @param  string $before Limit response to resources published before a given ISO8601 compliant date. (optional)
     * @param  int[] $exclude Ensure result set excludes specific IDs. (optional)
     * @param  int[] $include Limit result set to specific ids. (optional)
     * @param  int $offset Offset the result set by a specific number of items. (optional)
     * @param  string $order Order sort attribute ascending or descending. (optional)
     * @param  string $orderby Sort collection by object attribute. (optional)
     * @param  string $status Limit result set to webhooks assigned a specific status. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webhooksGetRequest($context = null, $page = null, $per_page = null, $search = null, $after = null, $before = null, $exclude = null, $include = null, $offset = null, $order = null, $orderby = null, $status = null)
    {

        $resourcePath = '/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if ($after !== null) {
            $queryParams['after'] = ObjectSerializer::toQueryValue($after, 'string');
        }
        // query params
        if ($before !== null) {
            $queryParams['before'] = ObjectSerializer::toQueryValue($before, 'string');
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'multi', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($include)) {
            $include = ObjectSerializer::serializeCollection($include, 'multi', true);
        }
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby, null);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webhooksIdDelete
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Webhook
     */
    public function webhooksIdDelete($id, $force = null)
    {
        list($response) = $this->webhooksIdDeleteWithHttpInfo($id, $force);
        return $response;
    }

    /**
     * Operation webhooksIdDeleteWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function webhooksIdDeleteWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdDeleteRequest($id, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webhooksIdDeleteAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdDeleteAsync($id, $force = null)
    {
        return $this->webhooksIdDeleteAsyncWithHttpInfo($id, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webhooksIdDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdDeleteAsyncWithHttpInfo($id, $force = null)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdDeleteRequest($id, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webhooksIdDelete'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  bool $force Required to be true, as resource does not support trashing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webhooksIdDeleteRequest($id, $force = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webhooksIdDelete'
            );
        }

        $resourcePath = '/webhooks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webhooksIdGet
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Webhook
     */
    public function webhooksIdGet($id, $context = null)
    {
        list($response) = $this->webhooksIdGetWithHttpInfo($id, $context);
        return $response;
    }

    /**
     * Operation webhooksIdGetWithHttpInfo
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function webhooksIdGetWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdGetRequest($id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webhooksIdGetAsync
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdGetAsync($id, $context = null)
    {
        return $this->webhooksIdGetAsyncWithHttpInfo($id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webhooksIdGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdGetAsyncWithHttpInfo($id, $context = null)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdGetRequest($id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webhooksIdGet'
     *
     * @param  int $id Unique identifier for the resource. (required)
     * @param  string $context Scope under which the request is made; determines fields present in response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webhooksIdGetRequest($id, $context = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webhooksIdGet'
            );
        }

        $resourcePath = '/webhooks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webhooksIdPatch
     *
     * @param  \WooCommerce\Client\Model\Webhook4 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Webhook
     */
    public function webhooksIdPatch($body, $id)
    {
        list($response) = $this->webhooksIdPatchWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation webhooksIdPatchWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Webhook4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function webhooksIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webhooksIdPatchAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Webhook4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdPatchAsync($body, $id)
    {
        return $this->webhooksIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webhooksIdPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Webhook4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webhooksIdPatch'
     *
     * @param  \WooCommerce\Client\Model\Webhook4 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webhooksIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling webhooksIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webhooksIdPatch'
            );
        }

        $resourcePath = '/webhooks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webhooksIdPost
     *
     * @param  \WooCommerce\Client\Model\Webhook3 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Webhook
     */
    public function webhooksIdPost($body, $id)
    {
        list($response) = $this->webhooksIdPostWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation webhooksIdPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Webhook3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function webhooksIdPostWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdPostRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webhooksIdPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Webhook3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdPostAsync($body, $id)
    {
        return $this->webhooksIdPostAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webhooksIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Webhook3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdPostAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdPostRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webhooksIdPost'
     *
     * @param  \WooCommerce\Client\Model\Webhook3 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webhooksIdPostRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling webhooksIdPost'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webhooksIdPost'
            );
        }

        $resourcePath = '/webhooks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webhooksIdPut
     *
     * @param  \WooCommerce\Client\Model\Webhook2 $body body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Webhook
     */
    public function webhooksIdPut($body, $id)
    {
        list($response) = $this->webhooksIdPutWithHttpInfo($body, $id);
        return $response;
    }

    /**
     * Operation webhooksIdPutWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Webhook2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function webhooksIdPutWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdPutRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webhooksIdPutAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Webhook2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdPutAsync($body, $id)
    {
        return $this->webhooksIdPutAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webhooksIdPutAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Webhook2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksIdPutAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksIdPutRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webhooksIdPut'
     *
     * @param  \WooCommerce\Client\Model\Webhook2 $body (required)
     * @param  int $id Unique identifier for the resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webhooksIdPutRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling webhooksIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webhooksIdPut'
            );
        }

        $resourcePath = '/webhooks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webhooksPost
     *
     * @param  \WooCommerce\Client\Model\Webhook1 $body body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WooCommerce\Client\Model\Webhook
     */
    public function webhooksPost($body)
    {
        list($response) = $this->webhooksPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation webhooksPostWithHttpInfo
     *
     * @param  \WooCommerce\Client\Model\Webhook1 $body (required)
     *
     * @throws \WooCommerce\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WooCommerce\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function webhooksPostWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WooCommerce\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webhooksPostAsync
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Webhook1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksPostAsync($body)
    {
        return $this->webhooksPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webhooksPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \WooCommerce\Client\Model\Webhook1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webhooksPostAsyncWithHttpInfo($body)
    {
        $returnType = '\WooCommerce\Client\Model\Webhook';
        $request = $this->webhooksPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webhooksPost'
     *
     * @param  \WooCommerce\Client\Model\Webhook1 $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webhooksPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling webhooksPost'
            );
        }

        $resourcePath = '/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
